{"pages":[{"title":"About","text":"前言About算是博客里最让我好奇的了。透过About从而去了解作者，还真是极大的满足了心中的好奇心(笑)~ ME! ME! ME! 俺是Yuk，爱编程也爱画画的Yuk，梦想是有吃不完的水果 常用社交账号都放在头像下方了，欢迎唠嗑学习！ 联络邮箱 hi # yuk7.com （# &gt;&gt; @） 历史的进程(逃2016年搭了人生第一个博客，兜兜转转到了如今，以静下心来记录当下作为写博客的初衷。","link":"/about/index.html"},{"title":"归档","text":"","link":"/archive/index.html"},{"title":"留言","text":"来都来了，留个爪呗～","link":"/comments/index.html"},{"title":"好伙伴","text":"欢迎志同道合的小伙伴评论申请友链，原则是完全眼生的不加【画画人除外】 请在收到我的回复邮件后再于贵站添加本站链接 除开友链，咱也会放上自己单推的大佬哒 申请格式 - 网站名： 最好不要太长，控制在八个中文字符宽度内 - 网站地址： HTTPS站点链接，不接受HTTP - 网站头像地址： 你的头像HTTPS链接，请确保它为正方形或圆形 - 网站一句话描述： 简单描述 - 申请理由： 随便写点 🌰 - 网站名： 橙涩Yuk的水果摊 - 网站地址： https://blog.yuk7.com/ - 网站头像地址： https://cdn.jsdelivr.net/gh/yuk7-0v0/wp\\_cdn\\_resources/picBed/logo.jpg - 网站一句话描述： 一只正在转生画师的阿宅 - 申请理由： 俺也喜欢画画&amp;然然🤤","link":"/friends/index.html"},{"title":"","text":"@font-face{font-family:iconfont;src:url('iconfont.ttf?t=1638347230468') format('truetype')}.iconfont{font-family:iconfont!important;font-size:16px;font-style:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-pixiv:before{content:\"\\e51b\"}","link":"/css/pixiv_icon/iconfont.css"},{"title":"","text":"!function(e){var t,n,o,i,d,c='',l=(l=document.getElementsByTagName(\"script\"))[l.length-1].getAttribute(\"data-injectcss\");if(l&&!e.__iconfont__svg__cssinject__){e.__iconfont__svg__cssinject__=!0;try{document.write(\".svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}\")}catch(e){console&&console.log(e)}}function a(){d||(d=!0,o())}t=function(){var e,t,n,o;(t=document.createElement(\"div\")).innerHTML=c,c=null,(e=t.getElementsByTagName(\"svg\")[0])&&(e.setAttribute(\"aria-hidden\",\"true\"),e.style.position=\"absolute\",e.style.width=0,e.style.height=0,e.style.overflow=\"hidden\",t=e,(e=document.body).firstChild?(n=t,(o=e.firstChild).parentNode.insertBefore(n,o)):e.appendChild(t))},document.addEventListener?~[\"complete\",\"loaded\",\"interactive\"].indexOf(document.readyState)?setTimeout(t,0):(n=function(){document.removeEventListener(\"DOMContentLoaded\",n,!1),t()},document.addEventListener(\"DOMContentLoaded\",n,!1)):document.attachEvent&&(o=t,i=e.document,d=!1,function t(){try{i.documentElement.doScroll(\"left\")}catch(e){return void setTimeout(t,50)}a()}(),i.onreadystatechange=function(){\"complete\"==i.readyState&&(i.onreadystatechange=null,a())})}(window);","link":"/css/pixiv_icon/iconfont.js"},{"title":"","text":"{\"id\":\"\",\"name\":\"\",\"font_family\":\"iconfont\",\"css_prefix_text\":\"icon-\",\"description\":\"\",\"glyphs\":[{\"icon_id\":\"3507166\",\"name\":\"pixiv\",\"font_class\":\"pixiv\",\"unicode\":\"e51b\",\"unicode_decimal\":58651}]}","link":"/css/pixiv_icon/iconfont.json"}],"posts":[{"title":"Android软件数据备份以及管理优化","text":"2019.06 卖了XZ1，换了iPhone8，配合MacBook Pro真香~ 下面的大部分操作需要root 写在前面最近有些力不从心，重装macOS后又得重装Android(最近Sony终于咕咕咕的更新了安卓P)，服务器也都重装，因为有点系统洁癖。 这篇文章下我总结下安卓重装后的一些操作，会涉及到刷机前的备份准备以及刷机后系统的管理优化，希望对你有所帮助。 备份备份是个好习惯，即使不刷机定时备份也是很重要的，备份一般包括App和App的数据，短信联系人，各种系统设置之类的，在这里我们只考虑备份App和App的数据的情况 在备份之前我们先对安卓下软件数据进行了解。 备份原理在Android中的APK是Android Package的缩写，即Android安装包，其实就是一种压缩文件，安装软件时会自动把APK移动到/data/app/下，解压并把dex文件保存到/data/dalvik-cache/目录，接着在/data/data/目录下创建对应的应用数据目录。 /data/app/这个目录下都是第三方软件，而系统软件的APK存储在了/system/app/下 提下/system/app/ 和/data/app/的区别 /data/app/下的 普通用户可以卸载，/system/app/下的 只能root后删除。 /data/app/下的软件即使静默也可以收到各种广播信息，/system/app/下的就不能。 软件的私有数据大部分都存放在/data/data/和/storage/emulated/0/Android/data/下。 除了这两个有些大型游戏往往还会有个/storage/emulated/0/Android/obb/，OBB文件(Opaque Binary Blob)是安卓游戏通用数据包，存的都是游戏中所用到的资源，对于有些游戏会将OBB解包/storage/emulated/0/Android/data/目录下，但是也有直接读取不解包的。 开始备份有了以上的知识背景后我们就可以手动对应用进行备份了，不过这样不够优雅，手动复制打包移动这些操作早就有了很多自动化的软件了。 在这里我们使用钛备份进行各种备份和还原操作，具体的软件操作就不多说了，虽然界面万年不变但是还是比较容易上手的。 分析下钛备份生成的备份文件，我们会发现当备份一个App以及数据后会生成三个文件，一个文件以.properties结尾，里面记录了一些备份的系统环境和备份软件的版本号之类的信息，给以后还原加载验证用的，另外两个都是gz格式的压缩包，其中一个中含有APK，另一个里面还是个压缩包，压缩着该软件的各种数据，就是上文所提及到的/data/各种文件。 钛备份默认不备份软件的缓存文件，通过测试发现钛备份还不会备份obb文件，还得需要手动备份一下，不过问题不大，毕竟用得到obb的还是少数软件，在专业版中可以很方便的使用一键备份和还原所有，计划备份，支持各种国外云备份以及加密也是不错的，可以说是瑕不掩瑜了。 Swift Backup这个备份软件也很不错，支持Pro版计划备份，一键备份和还原，最重要的是支持obb·短信·通话·联系人备份！！，虽然仅支持Google Drive云备份，界面现代，一年订阅Pro1.99刀，5.99刀买断，还是很划算的。 备份文件分析的话，软件数据备份后，会有一个.app结尾的文件，后缀改成apk就是安装包，以.dat结尾的改成zip，里面压缩的就是上文提及到的各种软件数据文件夹(/data/下的)，以.extdat结尾的压缩的是/storage/emulated/0/Android/data/下的，以.exp结尾的是obb文件，只是改了个名字，大小没变。 另外还会生成一个.xml的文件，内容经过一些处理，不出意料和钛备份中的.properties文件作用差不多，如果我们在设置中设置了备份加密的话，密匙可能就是存在这个文件中。 至于备份通讯录和短信之类的文件涉及到数据库之类的，技术受限这里就不做分析了，感兴趣的可以尝试下。 备份工作做好就可以强刷固件了(Sony)，一般手机都是Recovery下卡刷ROM包的，具体流程Google一下各自手机型号刷机教程即可。 管理优化由于Android的开放，给了一些软件滥用权限可乘之机，为了保护个人隐私和手机的流畅，必须采取一些措施对付了。 管理工具软件建议先下一个类似于Appops的权限管理软件以及黑阀管理后台再安装各类软件，安装一个管理一个 如果你的手机能刷Xposed框架的话(推荐刷Magisk中的Systemless的Xposed)，有很多模块都很好用，由于我手机用的官方固件没法刷进Xposed…所以这里就只写点各类软件推荐。 Appops 管理软件的各种权限，可对付那种不给权限就不让用的流氓，但支付宝的SD卡读取权限压不住，仍可以读取，目前无解，大部分软件还是很管用的 Brevent(黑阀) 管理软件后台的软件，很管用就是了 SD Maid &amp; Dir 都是清理软件的，前者的话个人还用它来卸载和管理自启权限，后者的对国内流氓文件很棒 Airfrozen(空调狗) 冻结流氓和不常用软件的，这类软件很多，只是我一直都是用的这个就是了 Play上都可以下到，管理软件就差不多这些了 使用IFW管理缓存活动唤醒除开以上提到的工具，还值得一提的是是IFW(Intent Firewall)这个玩意。 这是一个起到过滤到Intent的东西，在Android中软件都是使用Intent这个玩意启动新活动、新服务等，我们可以使用这个来阻止一些并不需要的东西开启。 系统是读取/data/system/ifw/下的xml来过滤掉Intent(允许多个文件，可叠加)，我们可以自己编写xml进行过滤，具体怎么写，可以参考这里，也直接使用已经写好的xml文件Github ，复制到/data/system/ifw/下，xml改成644权限，无需重启即刻生效。 有些流氓会检查自己申请的服务有没有正常开启，如果没有就会一直发送请求，反而会导致系统资源的消耗和设备耗电量的增加，仁者见仁吧，至少微信等软件后台缓存低了不少。 总结?!现在手机性能普遍过剩，在我看来运用以上的方法管理好已经够用，最重要的还是保持良好的使用习惯，定时清理下垃圾，远离国内几大流氓厂，能用浏览器快捷解决的绝不下个软件，即使要下也去Play上下 愿国内安卓生态环境早日转好，虽然不抱什么希望就是了。","link":"/2018/11/08/Android%E8%BD%AF%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%BB%A5%E5%8F%8A%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/"},{"title":"Caddy搭建Typecho并用脚本监控重启","text":"2019-03-11，换成了香港服务器，完善重构一下文章，新增了caddy异常监控脚本 写在前面继重装macOS和Android后，咱终于也把自己最不熟悉的服务器给重装了，服务商和主题也换了，特此记录下，以备不时再用=。=，也希望能帮到各位吧。 一直以来，我都是使用Nginx + Mysql的组合，使用Let’s Encrypt的SSL配合脚本自动续期，每次都要折腾不少时间… 开始之所以去尝试Caddy就是被大佬安利，看上了它操作简单去的，本体更是简单到只有一个文件，用 Go 写的 Web 服务器，配置简洁，能一键开启并续期 HTTPS (Let’s Encrypt)，省事多了啊，官网还有不少插件可以安装，分分钟即可搭建好个博客或者文件管理 操作系统为Ubuntu 18.04 LTS。 Typcho下载直接上命令，将路径/var/www/blog.yuk7.com修改即可 1234567mkdir /var/www/blog.yuk7.com &amp;&amp; cd /var/www/blog.yuk7.com# 下载开发版wget http://typecho.org/build.tar.gztar -zxvf build.tar.gzcd buildmv * ../sudo chown -R www-data:www-data /var/www 安装PHP7.2和Sqlite 31234#更新系统apt-get update -y#安装PHP 7和Sqlite 3apt-get install php7.2-cgi php7.2-fpm php7.2-curl php7.2-gd php7.2-mbstring php7.2-xml php7.2-sqlite3 sqlite3 -y CaddyCaddy下载安装在官网记下你要使用到的插件名字，然后添加到下面的代码末尾运行安装即可 咱这里搭建博客只用到了http.cache和http.expires插件 1234567curl https://getcaddy.com bash -s personal# 例如我要使用到http.cache和http.expires的插件，运行curl https://getcaddy.com bash -s personal http.cache,http.expires# 安装后可以使用caddy -plugins来查看自己已安装的插件列表# 如果安装后又想加个插件时重新运行以上命令添加新插件名称至末尾 安装完成后，使用which caddy应该就会显示/usr/local/bin/caddy了 Caddy配置文件(Caddyfile)请直接参考这里和官方文档!!! 以下是我的配置，如果你是按照我上面的操作的话，大概只需要更改为自己的路径和域名，以及邮箱，保存为/etc/caddy/Caddyfile 12345678910111213141516171819202122232425yuk7.com, www.yuk7.com { redir https://www.yuk7.com{url}}https://www.yuk7.com, https://blog.yuk7.com { # 如果不需要记录log也可以直接删掉这一行 log / /var/log/caddy/blog.yuk7.com.log &quot;{remote} {when} {method} {uri} {proto} {status} {size} {&gt;User-Agent} {latency}&quot; cache gzip { level 4 } tls admin@yuk7.com header / Strict-Transport-Security &quot;max-age=31536000&quot; expires { match .css$ 1m match .js$ 1m match .png$ 1m match .jpg$ 1m } root /var/www/blog.yuk7.com fastcgi / /run/php/php7.2-fpm.sock php rewrite { if {path} not_match ^\\/admin to {path} {path}/ /index.php?{query} }} 其中使用到的cache需要提前安装好http.cache插件，expires也需要http.expires插件。 log文件操作 123vim /var/log/caddy/blog.yuk7.com.log # 新建log文件，vim用shift+z+z即可快速保存退出chown www-data:www-data /var/log/caddy/blog.yuk7.com.log # 配置权限systemctl reload caddy.service # 重载 Caddy开机自启这里我们选择使用systemd实现 先去下载官方提供的caddy.service到/etc/systemd/system/。 1sudo curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service 脚本里面用到了几个文件和文件夹需要我们自己手动创建，当然你也可以自己更改目录 /etc/caddy 放 Caddy 的配置文件，/etc/ssl/caddy 放证书，/var/www 是默认的网站目录。 123456sudo mkdir /etc/caddy /etc/ssl/caddy /var/wwwsudo chown -R root:www-data /etc/caddysudo chown -R www-data:root /etc/ssl/caddysudo chown www-data:www-data /var/wwwsudo chmod 0770 /etc/ssl/caddysudo touch /etc/caddy/Caddyfile 让 Caddy 开机自启 12sudo systemctl daemon-reloadsudo systemctl enable caddy.service 接着可以重启运行ps -ef grep caddy看看是否是否起作用。 如果没有使用systemctl status caddy.service查看报错，一般都是什么文件权限之类的小问题 Caddy的部分到此为止了。 接下来就是紧张刺激的安装Typecho了 然后浏览器打开你的域名/IP，不出意外就会见到Typecho的安装界面了，简单设置几个密码后，博客就搭建好了。 脚本监控caddy之前遇到过几次caddy挂了的情况，手动重启一下就好了，但是这事还是扔给脚本去做吧~ 以下脚本可以直接套用，只要把21行中的域名改成自己的即可 123456789101112131415161718192021222324252627282930313233#! /bin/bashhost_dir=&quot;/root/&quot; # 当前用户根目录proc_name=&quot;caddy&quot; # 进程名file_name=&quot;restart_caddy.log&quot; # 日志文件pid=0proc_num() # 计算进程数{ num=`ps -ef grep $proc_name grep -v grep wc -l` return $num}proc_id() # 进程号{ pid=`ps -ef grep $proc_name grep -v grep awk '{print $2}'`}# 通过curl模拟登录获取http_code,模拟登录参数仅供参考# 如果只需要判断某页面的状态可使用curl -I -s -w &quot;%{http_code}&quot; -o /dev/null http://www.baidu.com/ 直接获取即可# http_code=`curl -I -s -w &quot;%{http_code}&quot; -o -d &quot;userKey=admin&amp;pass=c9127e832b41a&quot; /dev/null http://portal.ly-sky.com/login.do?login= head -n 1 cut -d$' ' -f2`http_code=`curl -I -s -w &quot;%{http_code}&quot; -o /dev/null https://www.yuk7.com/`proc_numnumber=$?if [[ $number -eq 0 ]][[ $http_code -ne 200 ]] # 判断进程是否存在,页面状态是否是200then # nohup ./run.sh&gt;../logs/urp.log 2&gt;&amp;1 &amp; # 重启进程的命令，请相应修改 # nohup /usr/local/bin/caddy -log stdout -agree=true -conf=/etc/caddy/Caddyfile -root=/var/tmp -quic &amp; systemctl restart caddy.service sleep 3 #延迟3秒是为了确保进程已正常启动并方便获取pid，否则有可能获取不到pid proc_id # 获取新进程号 echo $pid, `date` &gt;&gt; $host_dir$file_name # 将新进程号和重启时间记录fi 修改权限并设置定时运行 123chmod 700 monitor_caddy.shcrontab -e # 加入下面这一行即可*/5 * * * * /root/monitor_caddy.sh 手动测试监控是否正常 123systemctl stop caddy.service./monitor_caddy.shcat restart_caddy.log # 如果有内容则代表脚本正常 总结Caddy的配置的确很简单，配合PHP 7.2和Sqlite 3总共占的内存比使用Nginx+PHP 7.2+Mysql小了不少，性能差距咱也没有感觉有啥差，吹爆~","link":"/2019/03/22/Caddy%E6%90%AD%E5%BB%BATypecho%E5%B9%B6%E7%94%A8%E8%84%9A%E6%9C%AC%E7%9B%91%E6%8E%A7%E9%87%8D%E5%90%AF/"},{"title":"Flask数据库笔记","text":"写在前面想了想，整体笔记这个表述还是太过于笼统了，单独拎出来也方便查询复盘。这里我们只是涉及到Flask-SQLAlchemy的使用层次上，深入的架构关系处理按下不表。以下内容参考摘抄于《Flask+Web开发实战》，是本好书，感谢作者李辉。 初始配置安装1&gt; pip install flask-sqlclchemy 扩展的初始化:实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序实例app，完成。 1234from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)db = SQLAlchemy(app) 连接数据库服务器 配置SQLite数据库URI1234import os ...app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///' + os.path.join(app.root_path, 'db.sqlite3'))app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False 这里图方便用的就是SQLite，只需要提供文件路径即可[这里是app同路径下db.sqlite3]。 但在生产环境下更换到其他类型的DBMS时，数据库URL会包含敏感信息，所以这里优先从环境变量DATABASE_URL获取。 【注意不同操作系统下斜杆数不一致】所以也就玩具项目图方便用下，其他情况下还是用Mysql等更专业的吧。 配置Mysql数据库URI1234import os ...app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL','mysql://root:password@127.0.0.1:3306/database_name')app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False 需要提前开启Mysql服务器以及创建好database_name。 安装并初始化Flask-SQLAlchemy后，启动程序时会看到命令行下有一行警告信息。这是因为Flask-SQLAlchemy建议你设置SQLALCHEMY_TRACK_MODIFICATIONS 配置变量，这个配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事件通知系统。 这个配置键的默认值为None，如果没有特殊需要，我们可以把它设为 False来关闭警告信息: 1app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False 定义数据库模型 这里我就演示了下几个常用的 1234567from datetime import datetime ...class Note(db.Model): id = db.Column(db.Integer, primary_key=True) author = db.Column(db.String(25), nullable=False) created_time = db.Column(db.DateTime, default=datetime.now, nullable = False) body = db.Column(db.Text,default='Write Something') 默认情况下，Flask-SQLAlchemy会根据模型类的名称生成一个表名称，生成规则如下:Message –&gt; message # 单个单词转换为小写FooBar –&gt; foo_bar # 多个单词转换为小写并使用下划线分隔 Note类对应的表名称即note 如果你想自己指定表名称，可以通过定义 __tablename__属性来实现。 创建数据库表定义好模型后就可以直接创建了。 1234567891011import click ...@app.cli.command()@click.option('--drop', is_flag=True, help='Create after drop.')def initdb(drop): if drop: click.confirm('This operation will delete the database, do you want to continue?', abort=True) db.drop_all() click.echo('Drop tables.') db.create_all() click.echo('Initialized database.') 这里自定义了个flask命令flask initdb，用click还添加了个--drop的参数。 但是我们这里为了让数据库中实际的表同步数据模型的变化【添加或删除字段，修改字段的名称和类型之类的】是直接暴力的db.drop_all()后再重新db.create_all()，会直接清空表中原有的数据，迁移表原有数据后文中写。 数据库操作为了方便，接下来使用flask bash进行演示，在此之前我们先将自己定义的数据库模型类以及db手动传入到上下文中。 1234# 传入bash上下文@app.bash_context_processordef make_bash_context(): return dict(db=db, Note=Note) 终端进入项目所在路径执行以下命令。 12345678910&gt; flask initdb --dropThis operation will delete the database, do you want to continue? [y/N]: yDrop tables.Initialized database.&gt; flask bashPython 3.7.5 (default, Nov 29 2019, 17:17:51) [Clang 11.0.0 (clang-1100.0.20.17)] on darwinApp: app [production]Instance: /Users/Mosaic/Programming/Flask/instance&gt;&gt;&gt; 用上一小节的命令flask initdb --drop我们先同步好了模型表，然后进入flask bash 。 【下文中&gt;&gt;&gt;开头的都代表是在flask shell模式中】增删改查。 1234567891011&gt;&gt;&gt; note1 = Note(body='hello')&gt;&gt;&gt; note2 = Note(body='world')&gt;&gt;&gt; db.session.add(note1) # 增&gt;&gt;&gt; db.session.add(note2)&gt;&gt;&gt; db.session.commit() # 每次更改都要commit才能同步到数据库&gt;&gt;&gt; db.session.delete(note1) # 删&gt;&gt;&gt; db.session.commit()&gt;&gt;&gt; note1.body = 'giao!' # 改&gt;&gt;&gt; db.session.commit()&gt;&gt;&gt; Note.query.filter_by(body='giao!').first() == note1 # 查True 一般来说，一个完整的查询遵循下面的模式: &lt;模型类&gt;.query.&lt;过滤方法&gt;.&lt;查询方法&gt; 和filter()方法相比，filter_by()方法更易于使用。 在filter_by() 方法中，你可以使用关键字表达式来指定过滤规则。更方便的是，你可以在这个过滤器中直接使用字段名称。 下面的示例使用filter_by()过滤器完成了同样的任务: 12Note.query.filter_by(body='SHAVE').first()# 等价于 Note.query.filter(Note.body='SHAVE').first() 其他的不一一举例了。 建立模型之间几种基础的关系模式单向和双向关系1234567891011class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) books = db.relationship('Book', back_populates='writer') # books = db.relationship('Book')class Book(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') # writer = db.relationship('Writer') 这里我们定义了两个模型，都定义了db.relationship relationship()。 函数的第一个参数为关系另一侧的模型名称，在Writer中它会告诉SQLAlchemy将Writer类与Book类建立关系。 如果db.relationship只被定义在Writer中，而Book中没有，就叫单向关系【只能从Writer查询到books，不能从Book方向查询自己的Writer】，两边都有就是双向关系【双方可以互查】。 而back_populates参数是用来连接两边的relationship的，值为对面关系名字，从而实现未commit之前两边关系的同步。 【例如删掉了Writer A的Book B，Book B的Writer A也会被同步删除】，但是不管加没加back_populates参数，commit之后两边关系总会同步好的【之所以加重未commit之前是因为自己一个个测试出来的…当初对back_populates这个参数有点疑惑坑，涉及到了后面的级联】 其他参数如下，不一一举例了，backref是隐式双向，不推荐，uselist可以用在一对一关系中，secondary用在多对多关系中。 【下面几种关系都默认使用双向关系】 一对多/多对一定义关系的第一步是创建外键。外键是(foreign key)用来在A表存储B表的主键值以便和B表建立联系的关系字段。 因为外键只能存储单一数据(标量)，所以外键总是在“多”这一侧定义。 多本书属于同一个作者，所以我们需要为每本书添加外键存储作者的主键值以指向对应的作者。 在Book模型中，我们定义一 个writer_id字段作为外键: 123class Book(db.Model): ...writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) 这个字段使用db.ForeignKey类定义为外键，传入关系另一侧的表名和主键字段名，即writer.id。 实际的效果是将book表的writer_id的值限制为Writer表的id列的值。 它将用来存储Writer表中记录的主键值 再加上双向关系，一个一对多/多对一就完成了。 12345678910class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) books = db.relationship('Book', back_populates='writer')class Book(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') 当Writer查询books时，会返回所有Book.writer_id与Writer.id一致的Book【返回列表】，而当Book查询Writer时，会返回Writer.id与writer_id一致的Writer【返回单个值】。 一对一一对一就是再一对多/多对一的基础上加上了个参数。 下面假设一个作者一生只写一本书，一本书也只能有一个作者 12345678910class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) book = db.relationship('Book', back_populates='writer', uselist=False)class Book(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') 在Writer的relationship加上了uselist=False，这将表示只能返回单个值了。 多对多需要额外定义一个表来处理两边的外键对应关系。 123456789101112association_table = db.Table('association',db.Column('student_id', db.Integer, db.ForeignKey('student.id')),db.Column('teacher_id', db.Integer, db.ForeignKey('teacher.id')))class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship('Teacher', secondary=association_table, back_populates='students')class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20)) 迁移数据库我们使用Flask-Migrate来实现保留数据更改表。 安装1&gt; pip install flask-migrate 实例化1234567from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migrateapp = Flask(__name__) ...db = SQLAlchemy(app)migrate = Migrate(app, db) # 在db对象创建后调用 创建迁移环境在开始迁移数据之前，需要先使用下面的命令创建一个迁移环境: 1&gt; flask db init 生成迁移脚本使用migrate子命令可以自动生成迁移脚本: 1234&gt; flask db migrate -m &quot;add note timestamp&quot; ...INFO [alembic.autogenerate.compare] Detected added column 'message.timestampGenerating /Path/to/your/database/migrations/versions/c52a02014635_add note_timestamp.py ... done 这条命令可以简单理解为在flask里对数据库(db)进行迁移(migrate)，-m 选项用来添加迁移备注信息。 从上面的输出信息我们可以看到，Alembic检测出了模型的变化:表note新添加了一个timestamp列，并且相应生成了一个迁移脚本 c52a02014635_add_note_timestamp.py【迁移命令是由Alembic自动生成的，其中可能包含错误，所以有必要在生成后检查一下】 因为每一次迁移都会生成新的迁移脚本，而且Alembic为每一次迁移都生成了修订版本(revision)ID，所以数据库可以恢复到修改历史中的任一点。 正因为如此，迁移环境中的文件也要纳入版本控制。 有些复杂的操作无法实现自动迁移，这时可以使用revision命令手动创建迁移脚本。这同样会生成一个迁移脚本，不过脚本中的upgrade()和downgrade()函数都是空的。 你需要使用Alembic提供的Operations对象指令在这两个函数中实现具体操作，具体可以访问Alembic官方文档查看。 更新数据库生成了迁移脚本后，使用upgrade子命令即可更新数据库: 12&gt; flask db upgrade ...INFO [alembic.runtime.migration] Running upgrade -&gt; c52a02014635, add note timestamp 如果还没有创建数据库和表，这个命令会自动创建； 如果已经创建，则会在不损坏数据的前提下执行更新。如果你想回滚迁移，那么可以使用downgrade命令(降级)，它会撤销最后一 次迁移在数据库中的改动，这在开发时非常有用。 比如，当你执行upgrade命令后,发现某些地方出错了，这时就可以执行flask db downgrade命令进行回滚，删除对应的迁移脚本，重新生成迁移脚本后再进行更新(upgrade)。 最后还有一些什么级联操作，事件监听之类的没有提到……，写笔记的时间比学习内容时间都要多是好事还是坏事，emmmmm，不过思路还是清晰了，管他呢~","link":"/2020/02/02/Flask%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"},{"title":"Java语言学习(一)","text":"写在前面后端还是Java需求大些，特此学习，由于已有其他语言基础，花了几天仅记录一下自己留意或者模糊的一些方面 命名规范 类名大驼峰 HelloWorld 变量名和方法名小驼峰 helloWorld 数据类型数据类型分类基本数据类型： 整数型：byte short int(默认) long浮点型：float double(默认)字符型：char布尔型：boolean 引用数据类型： 字符串，数组，类，接口，Lambda… 注意事项： 字符串是引用类型，不是基本类型 浮点型是近似值，不精确 数据范围跟字节数不一定相关，例如：float的4个字节比long8字节表示范围更大，float是用科学计数法存储 数据类型运算注意事项： byte/short/char 在进行数字运算时会自动转成int型1234byte num1 = 40;byte num2 = 50;byte sum1 = num1 + num2;// 报错，因为byte/short/char 在进行数字运算时会自动转成int型int sum2 = num1 + num2; // OK boolean不能发生数据类型转换 任何数据类型和字符串String进行连接的时候，结果都会变成字符串 编译器的常量优化1234short a = 5;short b = 8;short c = a + b; // 报错，需要c为intshort d = 5 + 8; // OK，因为编译器会在编译后将常量运算5+8替换成13，因为没超过short范围，还会自动加上(short)强制转换 只会对全是常量的运算优化，如果是short e = 5 + a + 8依旧会报错，因为有a变量 方法的重载Java语言学习(一)参数个数，参数类型，参数顺序相关参数名称，返回值类型无关 数组的默认值整数0，浮点0.0，字符’\\u0000’，布尔false，引用null 内存划分 栈(Stack):方法中的局部变量，方法运行也都是在栈中，一旦超出作用域立刻从栈内存中消失 堆(Heap):new出来的东西类什么的都在堆中，都附带默认值和地址值 方法区(Method Area):存储.class相关信息，包含方法的信息 寄存器(PC Register):与CPU相关 本地方法栈(Native Method Stack):与操作系统相关 举例： 局部变量和成员变量 定义位置不一样，局部在方法内部，成员在类内部，方法外部 默认值不一样，局部无默认值，成员有 存储位置不一样，局部跟着方法走，在栈中，成员跟着类走，在堆中 作用域不一样，局部方法外就不能用了，成员全体内部都可以 生命周期不一样，局部在栈中，方法进栈而诞生，出栈即消失，成员在堆中，对象创建而诞生，对象被垃圾回收即消失 ArrayList泛型Class ArrayListE是泛型，只能是引用类型int &gt;&gt; Integerchar &gt;&gt; Character除开上面两种其他基本类型都是首字母大写 字符串String字符串String常量池只有直接在程序中用写上双引号的字符串才会在堆中字符串常量池，且String实际上用的都是byte数组。引用类型的==是比较地址值基本类型==才算是数值的比较 字符串常用方法字符串值的比较equals即可比较equalsIgnoreCase忽略大小写如果是一个常量和一个变量相互比较，推荐把常量放在前面&quot;abc&quot;.equals(str);，可以避免str为null时调用equals的空指针异常报错 字符串与获取相关方法1234public int length()public String concat(String str)// 返回拼接好的字符串，原字符串不变public char charAt(int index)// 获取指定位置字符public int indexOf(String str)// 返回首次出现的索引值，没有返回-1 字符串与截取相关方法12public String substring(int index)// 从index开始到末尾截取返回public String substring(int begin, int end)// 截取从begin开始到end结束，包左不包右 字符串与转换相关方法123public char[] toCharArray()// 返回拆分成字符数组public byte[] getBytes()// 返回拆分字节数组public String replace(CharSequence oldString, CharSequence newString)// 把所有的老字符替换成新字符，并返回 字符串与分割相关方法1public String[] split(String regex) 正则表达中.代表匹配任意字符，如果想.分割的话需要写成\\\\. 静态Static 静态不能直接访问非静态，因为内存中先有静态内容后面才有非静态内容的 静态代码块也要比构造方法先执行，首次用到类会调用，且只会在此调用一次 静态方法中不能用this 静态最好用类名来调用 静态数据存储在方法区中的静态区 Arrays方法12public static String toString(数组)// 数组转成字符串public static void sort(数组) // 默认升序排序 Math 数学工具类12345Math.abs()// 取绝对值Math.ceil()// 向上取整Math.floor()// 向下取整Math.round()// 四舍五入,ps:只有他不带小数点，上面三个都带Math.PI// pai 继承直接通过子类对象访问成员变量：谁调用谁优先，看等号左边是谁，没有才向上找间接通过成员方法访问成员变量：方法属于谁，就优先谁，没有才向上找 重写/覆盖覆盖重写：在继承关系当中，方法的名称一样，参数列表也一样 @Override 加在方法上一行可以检测是否覆盖重写了 子类的覆盖重写方法的返回值必须【小于等于】父类方法 子类方法权限必须【大于等于】父类方法 public &gt; protected &gt; (default) &gt; private ps:(default)指什么都不写 父子的构造方法 子类构造方法中默认会自动调用super()，先执行父类构造方法再是子类 手动调用父类有参构造的话super(param)必须在子类构造方法中第一行，且只能调用一次。 抽象类 抽象类不能创建对象 抽象类中可以有构造方法，是给子类用的 抽象类中可以没有抽象方法，但是有抽象方法的必须是抽象类 抽象类必须覆盖重写所有抽象方法，除非子类还是抽象类 接口 接口中的成员变量都是常量，都是public static final，必须赋值，且之后不能改变。常量最好是全大写，用下划线分割单词 接口中最重要的是抽象方法，public abstract 返回值类型 方法名称(参数列表)，必须却不覆盖重写，除非子类是抽象类 Java 8 开始，接口中允许定义默认方法，public default 返回值类型 方法名称(参数列表)，也可以被覆盖重写 Java 8开始，接口中允许定义静态方法，public static 返回值类型 方法名称(参数列表)，【只能用接口名调用，不能用实现类调用，这和继承不一样】 Java 9开始，接口中允许定义私有方法，private 返回值类型 方法名称(参数列表)，private static 返回值类型 方法名称(参数列表)，注意：private只能接口内部调用，不能被实现类和别人使用。 注意事项 继承只能唯一父类，接口可以多个同时实现 接口是没有静态代码块和构造方法的 多个接口中有重复的抽象方法，只需要实现一次 多个接口中有冲突的默认方法，必须覆盖重写来解决冲突 多个接口中的默认方法和父类方法冲突，优先使用父类当中的方法。 接口可以多继承 多态就是父左右子，反过来了，范围大的在左边Fu obj = new Zi(); 成员变量跟继承一样：直接通过子类对象访问成员变量：谁调用谁优先，看等号左边是谁，没有才向上找间接通过成员方法访问成员变量：方法属于谁，就优先谁，没有才向上找 123Fu obj = new Zi();obj.num// 成员变量访问的是Fu类的num，即时Zi中也有numobj.over()// 成员方法如果Zi类覆盖重写了，则用Zi类中的方法，且方法中用的成员变量也是Zi类中的 成员方法一句话口诀：编译看左，运行看右指的是编译即写代码时，.出来的东西都只看Fu类，例如：obj.methodZi();就会报错。运行时看右即，obj.method();优先等号右边的成员方法，找不到才向上找父类 向上转型和向下转型向上转型就是左父右子，从小范围转为大范围，eg：Animal a = new Cat();向下转型可以相当于把向下转型【还原】eg:Cat cat = (Cat) a，把进行向上转型成动物的猫向下转型恢复成猫 Instanceofanimal instanceof Cat，检测animal父类引用本来是不是Cat 权限修饰符 public protected (default) private 同一个类 Y Y Y Y 同一个包 Y Y Y N 不同包子类 Y Y N N 不同包非子类 Y N N N 内部类指在类的内部再定义一个类，注意：内用外，随意用，外用内必须要内部类对象 间接方式：在外部类的方法中使用内部类然后main再调用外部类的方法，曲线救国直接方法:【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 】 内部类与外部类重名外部类名称.this.外部类成员变量名，Outer.this.num 类的权限修饰符 外部类：public protected 成员内部类：public protected (default) private 局部内部类：什么都不能写，不是(default) 局部内部类访问所在方法的局部变量该局部变量必须是事实不变（可以不加final，但是要满足不变）这是因为方法中的局部变量随着方法入栈而诞生，出栈而消失，但是方法中的类却不会出栈就消失，这就必须要求局部内部类用的方法局部变量不变！ 匿名内部类当接口的实现类(或者是父类的子类)只需要使用唯一一次，则可以用 123接口名称 对象名 = new 接口名称(){ //覆盖重写所有抽象方法};","link":"/2022/01/25/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"},{"title":"Python虚拟环境大杂烩","text":"2021年复盘，Hatch在写完这篇文章后就再也没有新的更新，看来还真不能乱立Flag，hhhh 写在前面距离上篇博客差了半年，很惭愧，因为促使自己写博客的动力之一就是接触了新东西，想记录下来，这大半年实在不太在状态，写了几篇文章发布后又删除了，好在最近感觉好了不少。 这个学期开始明显感觉校内网限速严重了许多，时不时还断连需要重新认证一下，体验很不好，尤其是用Pipenv安装一些包的时候，尽管知道安装慢很大一部分是网络的问题，但当我看到Pipenv安装报错时，也渐渐对Pipenv起了一些疑虑，有时当我创建一个新的虚拟环境需要很长时间，有时候又Locking很久……，那颗折腾的心又躁动了起来。 为什么需要虚拟环境防止各种项目冲突顺便方便的导出所有依赖，简单的例子就是A项目中需要的是Django1.0，而B项目中需要的是Django2.0，为了防止来回卸载安装，所以我们使用虚拟环境分别配置单独的运行环境 虚拟环境大杂烩光是Pycharm所支持的就有 virtualenv Conda Pipenv等等 以及看大佬推荐的Poetry Conda 最后还是选择了顺手的 Hatch 选择哪种虚拟环境工具好先给出目前的个人结论：用回 virtualenv/venv 和 pip不一定是最方便的，但是至少更可靠 之前我一直都是用的Pipenv，说实在的除了偶尔Creating&amp;Locking慢了点，并没有遇到什么大问题，但当我看到 不要用 Pipenv 改变了 ‘我用着舒服你那问题我没遇见就接着用下去’ 的想法。 其中最让我不能接受的就是打着官方暧昧关系进行宣传以及快一年没有新的 releases 。 既然已经有了换的心思，满怀希望的去尝试大佬推荐的 Poetry ，嗯官网界面很对我口味，结果正当我安装好初始化时现实又给我来了一巴掌。 1234567→ poetry initThis command will guide you through creating your pyproject.toml config.[UnicodeDecodeError]'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128) 溜了溜了，连最基础的路径下创建文件都能整一个编码错误的项目我是更不敢用了，还是老办法吧。 重回 virtualenv 和 pip 时代这里我还用到了virtualenvwrapper这个工具来简化virtualenv的操作 1pip install virtualenv virtualenvwrapper 123456789101112131415161718# 环境配置# 查看 virtualenvwrapper.sh 路径$ which virtualenvwrapper.sh/usr/local/bin/virtualenvwrapper.sh# 配置环境变量 (以后创建的环境目录都集中放在 $WORKON_HOME 目录下管理了)# 配置文件位置: ~/.bashrc (bash) 或 ~/.zshrc (zsh) (Linux/macOS（win自行搜索）)export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh# 简化命令 ~/.zshrc (zsh)# which python python3 得到-p后的参数值alias mkv3='mkvirtualenv -p /usr/local/bin/python3'alias mkv2='mkvirtualenv -p /usr/local/bin/python'alias lsv='lsvirtualenv'alias rmv='rmvirtualenv'alias shv='showvirtualenv'alias dev='deactivate' 常用命令 123456789101112131415161718192021222324# workon 进入切换 环境$ workon ENVNAME# mkvirtualenv 创建环境$ mkvirtualenv ENVNAME# lsvirtualenv 展示环境列表$ lsvirtualenv [-b] [-l] [-h]# rmvirtualenv 删除环境$ rmvirtualenv ENVNAME# cpvirtualenv 复制环境$ cpvirtualenv ENVNAME [TARGETENVNAME]# allvirtualenv 所有环境运行命令 (比如安装包)$ allvirtualenv command with arguments$ allvirtualenv pip install -U pip# deactivate 退出当前环境$ deactivate# mkproject 创建项目$ mkproject [-f--force] [-t template] [virtualenv_options] ENVNAME 六、发展中的Hatch(不支持Python2)就在我准备收尾时，突然发现了 Hatch 这个项目，基于virtualenv 简单安装使用下来发现意外的很舒服，具体安装步骤见项目主页，这里简单回顾提及下 12345678910# 安装virtualenv和Hatchpip3 install virtualenv hatch# 如果重启后hatch用不了那么可能是你没有配置好python的PATH# 配置环境变量(Linux/macOS（win自行搜索）)# 配置文件位置: ~/.bashrc (bash) 或 ~/.zshrc (zsh)&gt; which python3 /usr/local/Cellar/python/3.7.4/bin&gt; export PATH=/usr/local/Cellar/python/3.7.4/bin:$PATH 常用命令 1234567891011121314151617181920212223# 列出所有的虚拟环境（~/.virtualenvs）hatch env -l# 创建虚拟环境hatch env envname# 进入虚拟环境hatch bash envname# 删除虚拟环境hatch shed -e envname# 退出虚拟环境exit# 列出所有以保存的pypathhatch pypath -l# 添加一个指向/usr/bin/python名字为py2的pypathhatch pypath py2 /usr/bin/python# 删除一个pypathhatch shed -p py2# 使用指定的pypath(这里是py2)作为虚拟环境的解释器hatch env -py py2 old# 简化命令 ~/.zshrc (zsh)alias inv='hatch bash'alias lsv='hatch env -l'alias rmv='hatch shed -e' 目前上面这些功能其实和virtualenv差不多，但是项目主页上的TODO中有一行写到python - installs the desired version of Python. will work on each platform，这代表以后版本更新后也可以自由的像Conda那样创建虚拟环境的时候直接指定特定的Python版本。 （值得一提的是：之前我也尝试去用了下Conda来管理，但是他会和pip有一定冲突，而且如果用Conda install会有很多包找不到，在虚拟环境下安装pip又会多出几个额外的依赖，所以放弃了） 期待Hatch后续的更新，毕竟我切换Python版本还是用的少的。","link":"/2019/11/29/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%A4%A7%E6%9D%82%E7%83%A9/"},{"title":"Sony Xperia XZ1(G8342)强刷笔记","text":"2019.06 卖了XZ1，换了iPhone8，配合MBP真香~ 不是同型号或者不是索尼手机的，本文并没有啥参考价值 写在前面由于2700mAh超大电池而且无root的XZ1在各类流氓面前不堪一击，为了摆脱一日二充的处境，咱只得解锁root了…带来的就是无法保修和没了OTA更新，且为了及时打上安全补丁不得不隔个月就得刷个机… 但是疏于记录…每次刷都会浪费很多时间，那就简单写下吧已解锁BL锁 刷机之前备份以及刷机后的操作之前也写过一篇，可以直接拿来用 Android软件数据备份以及管理优化 记得提前退出谷歌账号 一堆用得着的散东西以下的连接都是给的更新页，所以就不用担心旧版本什么的问题了 XperiCheck 很方便的查看各区域的固件更新情况 XperiFirm 下载固件用的 Flashtool 我只是用来安装驱动了 Newflasher 强刷命令行工具 TWRP RECOVERY Magisk root权限管理 Shadowsocks 上互联网恢复备份 Minimal ADB and Fastboot =。= EdXposed 安卓9上也能用的Xposed 动手惹先用XperiFirm下载最新的固件，众所周知的原因，请先设置好代理再下载… 美版固件因为版权问题用不了指纹…亲身踩坑QAQ 下载完后删除simlock文件，再将Newflasher解压到刚刚下好的固件同文件夹下，接着将手机彻底关机后按着音量下键来连接电脑，这样手机会进入绿灯模式，运行Newflasher，按照提示刷机完成即可，一般都是连续输入两次“n”。 之前没有刷过的应该是会缺少驱动出现问题…需要去找Flashtool的安装目录下的 Flashtool-drivers.exe（一般默认安装在 C:\\Flashtool\\) ，安装蓝 / 绿灯模式必须的两个驱动 Flashmode Drivers 和 Fastboot Drivers（就是第一个和第二个打勾） 如果是第一次安装估计会失败，需要禁用驱动数字签名后再进行安装。 驱动安装好后就可以继续在绿灯模式下用Newflasher强刷系统了。 强刷完系统后开机去开发者模式中打开USB调试后连接电脑，到Minimal ADB and Fastboot安装目录下运行cmd-here.exe并且将之前下载好的TWRP.img文件放进来，按如下命令操作即可 12345adb devicesadb reboot bootloaderfastboot devicesfastboot flash recovery TWRP.imgfastboot reboot 完成后音量下键加开机键进入recovery刷入Magisk。 安装EdXposed之前需要刷好Riru-core之类的，具体见EdXposed","link":"/2019/04/07/Sony%20Xperia%20XZ1(G8342)%E5%BC%BA%E5%88%B7%E7%AC%94%E8%AE%B0/"},{"title":"从WordPress迁移到Hexo，我都做了些什么","text":"前言目前主流的博客大体分成动态博客和静态博客，相比于动态博客，静态博客基本不需要维护，也不依赖数据库等工具，降低了风险。有着众多免费部署的方案，成本低。 但也有其不便之处，像后台管理等没有动态博客方便，一些需求需要借助于其他平台实现，例如评论功能等。 迁移的契机是学习了下GitHub Actions，可以很方便的实现持续集成和部署（CI/CD），况且自己购买的VPS搭建WordPress下来访问速度并不满意。 过了这么多年，当年使用过一段时间的Hexo仍然流行，咱就接着用这个静态框架吧。 迁移数据官方文档写的清楚了从WordPress迁移 1234# 安装hexo-migrator-wordpress插件$ npm install hexo-migrator-wordpress --save# 迁移所有文章，&lt;source&gt;是WordPress导出的文件路径，(“Tools” → “Export” → “WordPress”)$ hexo migrate wordpress &lt;source&gt; 手工审阅所有生成的markdown文件，检查其中是否有错误。 利用Github Actions实现持续集成和部署（CI/CD）Github Actions介绍 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 阮一峰 GitHub Actions 入门教程这里只引用了个介绍，具体语法教程文中也有，感兴趣的也可以学习下。 以前我们都是在本地环境下用hexo g &amp;&amp; hexo s 来生成和启动博客的，效果满意后hexo d 将publish文件夹push到Github Pages的仓库里来实现博客的更新。 这种方法因为只上传了本地生成好的静态网页文件，不能追踪博客框架自身配置代码文件，本地环境迁移麻烦，临时换一台设备更新博客就捉急了。 使用Github Actions后，我们只需要将博客整个项目代码上传，它将自动调用hexo g生成静态文件并部署，实现了整个项目的追踪。 具体使用这里我们会用到两个仓库。一个私人仓库blog-source，用来存储整个博客项目代码的。一个公开仓库github-name.github.io，用来存储生成的静态文件，github-name就是你Github用户名，这里我就是Yuk-0v0.github.io。 首先本地项目根目录中创建.github/workflows/hexo-deploy.yml文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# .github/workflows/hexo-deploy.ymlname: hexo deploy# main分支push的时候触发on: push: branches: - main jobs: build: # 配置运行环境，这里用的是ubuntu name: Build on node ${{ matrix.node_version }} and ${{ matrix.os }} runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [12.x] # 拉取本项目代码 steps: - name: Checkout uses: actions/checkout@v2 # 安装Node.js - name: Use Node.js ${{ matrix.node_version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node_version }} # 使用缓存依赖，加快速度 - name: Cache NPM dependencies uses: actions/cache@v2 with: path: node_modules key: ${{ runner.OS }}-npm-cache restore-keys: | ${{ runner.OS }}-npm-cache # 安装依赖 - name: Install dependencies run: | npm install # hexo clean和hexo generate - name: Clean and generate hexo run: | npm run clean npm run build # 将生成好的./public部署到公开仓库 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这里改成你自己的公开仓库 external_repository: Yuk-0v0/Yuk-0v0.github.io publish_branch: main publish_dir: ./public 接着使用ssh-keygen -o生成公开仓库的部署密钥，具体怎么生成key，可以参考生成 SSH 公钥，讲的很清楚。 然后分别在私人仓库的secrets中放入私钥，命名为ACTIONS_DEPLOY_KEY。 在公开仓库中添加公钥，名字随意。 这下就都配置好了，将整个项目提交到私人仓库中看看效果 12345678# 本地项目根目录下git initgit add .git commit -m &quot;first commit&quot;git branch -M main# 改成你自己的私人仓库链接git remote add origin https://github.com/Yuk-0v0/blog-source.gitgit push -u origin main 不出意外GitHub Actions运行成功且你访问Yuk-0v0.github.io就能看到博客页面了 其他较为重要的操作 用Vercel加速访问，参考使用Vercel加速博客访问。 私人仓库中添加Webhook更好的支持RSS等，参考提升RSS体验。 用hexo-all-minifier压缩生成文件，Github。 最后成果： 本文中提及到了三个重要外链（阮一峰，Vercel加速，提升RSS体验），为了防止死链导致参考失效，我已将网页内容以PDF格式并打包储存了起来，下载地址。","link":"/2021/12/04/%E4%BB%8EWordpress%E8%BF%81%E7%A7%BB%E5%88%B0Hexo%EF%BC%8C%E6%88%91%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"},{"title":"以更低的价格购买和续费域名","text":"2020年ICANN同意了Verisign无限期提高.com域名的价格，每年涨7%，连涨4年后停止2年，如此反复，大概如下图所示： 我也做了个表格来展示具体价格： 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 $7.85 $8.40 $8.99 $9.62 $10.29 $10.29 $10.29 $11.01 $11.78 $12.61 以上是域名商批发价，不含$0.18 ICANN的税，通常在没有活动的情况下个人购买价格还要更高，除了Cloudflare这种成本价出售的域名商。 本文将介绍如何以更低的价格购买和续费域名。 利用DomComp比价购买首年域名DomComp 带aff这个网站可以很直观的查询到各大域名商的价格以及目前的优惠码。 今天是2021年末，.com域名加税价格$8.58，在DomComp中查询发现大部份首年注册都有较大优惠（一般要新用户），Namecheap和GoDaddy都是首年不错的选择。 但也只限于首年了，之后的续费就开始贵了起来，Namecheap续费更是到了$14，所以我们只购买首年优惠大的，后续续费转到Cloudflare。 将域名转入Cloudflare续费2018年9月27日，Cloudflare官方博客宣布推出域名注册服务，承诺只收取成本费，不赚取利润。博客链接 因此很适合续费，但要注意免费提供的WHOIS privacy不会隐藏国家和省份，但邮箱等敏感信息还是隐藏的。 主流的域名后缀一般都支持转入，转入前Ctrl+F搜索一下支持的所有域名 迁入的过程Cloudflare引导的都很好，具体图文流程这里就不展示了，可以参考从Namecheap转移域名到CloudFlare，如果链接失效请访问快照。 我已经续满了10年，可以看到续费价格确实是成本价，值得注意的是，绑定完PayPal，续费前，先去PayPal设定里的付款选项，修改Cloudflare的自动付款汇率，网页不行就用app修改，这样就不会用PayPal默认汇率了。 另外，如果你和我一样使用了Vercel的话，则不需要启用Cloudflare橙色云朵CDN，只使用DNS，避免出现CDN套娃，参考Vercel文档。","link":"/2021/12/29/%E4%BB%A5%E6%9B%B4%E4%BD%8E%E7%9A%84%E4%BB%B7%E6%A0%BC%E8%B4%AD%E4%B9%B0%E5%92%8C%E7%BB%AD%E8%B4%B9%E5%9F%9F%E5%90%8D/"},{"title":"使用AirtestIDE和iOS-Tagent实现iOS端自动化脚本","text":"先前写过公主连接农场脚本，也写过昆特牌脚本，但还没有在iOS上实现过类似的自动化脚本，凑巧最近在蝗9号开服的碧蓝档案，遂尝试一番，Xcode上用网易开发的AirtestIDE和配套的iOS-Tagent。 环境配置iPadOS版本：14.2macOS版本：10.15.7Xcode版本：12.3iOS-TagentAirtest IDE 1.2.12不需要Apple开发者账号，普通的Apple ID就行。 这里需要注意的是Xcode版本和你要操作设备的iOS和macOS系统要匹配，这里俺找到了一个好网站，可以看到Xcode支持的的iOS SDK版本，以及最低支持macOS版本，同时支持下载。 如果你下载好的Airtest IDE若在使用中出现闪退或异常问题，可以使用命令行终端来打开应用： 输入 $ cd /Applications 进入应用程序文件夹， 运行指令$ ./AirtestIDE.app/Contents/MacOS/AirtestIDE 即可打开AirtestIDE 安装并测试WebDriverAgent 用Xcode打开WebDriverAgent.xcodeproj，并将iOS设备用数据线连接电脑，并在弹窗中信任 在Xcode顶部product &gt;&gt; Destination &gt;&gt; 选择你的iOS设备 添加证书，按照下图的路径在Signing &amp; Capabilities 下的Team中添加登陆自己的Apple ID 修改配置，这里我们需要修改两个地方。 先是Product Bundle Identifier，这里要求是唯一的，会进行联网检查，通常就是自己域名反写加项目名 第二个是Validate Workspace，改成Yes 这一步网上很多都没写，导致后面报错运行不起来 启动 command+U运行Test 然后你会发现iOS设备上会多出来个WebDriverAgentRunner，但是启动不起来，此时你需要去设置里信任一下才能正常工作 设置 -&gt; 通用 -&gt; 描述文件与设备管理 ，对应用WebDriverAgentRunner进行信任 接着再运行一次Test，点击左下角显示日志，看到输出如下http之类的就代表成功了 至此，Xcode相关操作已经结束 使用iproxy映射端口这里我们直接用Homebrew安装即可，没安装的可以参考这篇文章 12brew install libimobiledevice --HEADiproxy 8100 8100 此时我们用浏览器访问http://127.0.0.1:8100/status ，如果访问成功并且可以看到一些json格式的手机信息，即表示启动成功。 同时你也可以试着访问一下http://127.0.0.1:8100/inspector，正常应该是可以看到iOS设备的投屏，看不到也没关系，可能是脚本没有安装完全导致的，并不会影响Airtest IDE中的投屏，所以咱们也不用管它。 Airtest IDE连接直接输入127.0.0.1:8100 连接，看到iOS设备投屏就可以开始编写脚本了。 编写脚本俺这里只是用来刷初始过新手教程的，所以基本上没啥难度，只要跟着教程流程点就可以了 代码就只用到了touch,wait,sleep，复杂流程基本没有。 总结这次尝试重点不是在编写脚本上，而是简单走了遍iOS的自动化测试流程，不过Airtest IDE用来写一些脚本确实很方便，只是奈何并没有好点的windows设备，不然多开跑脚本效率会高很多。 ps：碧蓝档案的初始真难出货， 淘宝上大多都是科技刷，不推荐购买。","link":"/2021/11/13/%E4%BD%BF%E7%94%A8AirtestIDE%E5%92%8CiOS-Tagent%E5%AE%9E%E7%8E%B0iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"},{"title":"脚本助手：云手机上跑脚本的好伙伴","text":"写在前面书接上篇文章的刷初始，即使自己写了脚本简化了工作量，但是这游戏爆率实在难顶，一个好开局遥遥无期，凑巧在群里看到一些云手机里已经提供了对应的脚本，于是租了几个来刷一刷试试，效果确实好很多，效率也翻倍了。 可是一个新的需求出现了，当脚本卡住或刷出满足设定要求的时候会自动停下，我想要第一时间知道，而不是自己手动隔一段时间去查看其状态。 实现需求很简单，隔一段时间截图比对就行，通知就用最实用的发邮件。 基于 PyAndroidControl 这个项目俺写了ScriptAssistan【脚本助手】这个app，点击下载 服务端我这边设置的是每五分钟检测一次，抽空扔Github上，到时候也可以自行搭建 图标长这样 架构设计简单做了个图，大概如下图所示，基本大架构没怎么变。主要新增了些Server端的处理逻辑，安卓端规范POST请求以及权限使用的优化。 使用方法制作了个gif以便于直观展示，悬浮窗控制监控是否开启，软件需要root权限。 软件第一栏填写服务端地址，可以直接用我的http://sa.yuk7.com，每五分钟检测一次。第二栏填写该设备标示，用于在邮件提醒中多设备区分。第三栏填写通知邮箱，第一栏如果用我提供的则会用inform # yuk7.com（#&gt;&gt;@） 发送提醒邮件，不要屏蔽即可。 邮件提醒效果展示 开发札记广为流传的错误代码Python中实现图像对比发现很多都是用 这篇博客中的方法 核心代码如下： 12345from PIL import Imagefrom PIL import ImageChops image_one = Image.open(path_one)image_two = Image.open(path_two)diff = ImageChops.difference(image_one, image_two) 然而这广为抄袭到处转载的代码，实际上是错误的，大部分情况下不管怎么判断都会认定是相同的一张图，需要改成： 1234...image_one = Image.open(path_one).convert('RGB') image_two = Image.open(path_two).convert('RGB')... 类似的Stackoverflow也有讨论，大概是原方法是通过有无像素来判断是否为同一张图。而并非判断像素颜色。 PS：Google这简中搜索质量属实不行，这几个月内容农场仍在泛滥，简中一搜一大堆XX知识网在首页，这里分享一篇专门介绍和应对内容农场的文章 清理「内容农场」，还你清爽的 Google 中文搜索体验 。 Google对简中确实缺少重视，搜索用英文体验更好，麻了，以后试试英文写写博客？笑。 变量命名再也不纠结CODELF 这个网站可以让你查询单词来看到GitHub上同行们都是怎么命名的，挺有意思。 Ubuntu部署Flask WSGI参考Flask+Gunicorn+Gevent+Supervisor+Nginx生产环境部署这里只简单提及一些关键点，日后会专门写一篇详细的 如果pip安装Gevent时编译失败，则安装以下组件即可 123sudo apt-get install python3 python-dev python3-dev \\ build-essential libssl-dev libffi-dev \\ libxml2-dev libxslt1-dev zlib1g-dev \\ 这里WSGI用的是Gunicorn和Gevent的组合 使用Supervisor管理进程 123456789# /etc/supervisor/conf.d/ScriptAssistant.conf[program:ScriptAssistant]command=/home/ubuntu/ScriptAssistant/venv/bin/gunicorn -w 4 -b 127.0.0.1:2333 -k gevent wsgi:appdirectory=/home/ubuntu/ScriptAssistant/autorestart = truestartsecs = 5startretries = 3user = rootnodaemon = false 配置nginx开机自启 1sudo systemctl enable nginx 添加每天零点删除screenshots文件夹脚本clean_screenshots.sh 12345# ~/ScriptAssistant/clean_screenshots.shfind . -type d -name &quot;screenshots&quot; -exec rm -rf {} \\;chmod u+x ./clean_screenshots.sh # 配置可执行crontab -e0 0 * * * ~/ScriptAssistant/clean_screenshots.sh &gt; /dev/null 2&gt;&amp;1 # 每天零点执行","link":"/2021/11/25/%E8%84%9A%E6%9C%AC%E5%8A%A9%E6%89%8B%EF%BC%9A%E4%B8%80%E6%AC%BE%E7%9B%91%E6%8E%A7%E4%BA%91%E6%89%8B%E6%9C%BA%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E7%9A%84app/"},{"title":"记一次使用Crontab的错误排查","text":"我们常常会有一些定时任务处理的需求，Linux上大多使用Crontab来实现。 趁机记录下最近新开的一台机上使用Crontab的错误排查。 系统是Ubuntu20.04 前置需求每天定时运行一次虚拟环境下的Python脚本并留存运行日志保存起来。 最初实现根据需求，很容易写出下面的规则。 123crontab -e# '&gt;&gt;' 代表追加；2&gt;&amp;1 代表错误输出重定向标准输出，即记录所有输出15 8 * * * ~/XXX/start.sh &gt;&gt; ~/XXX/run.log 2&gt;&amp;1 start.sh内容如下 12source venv/bin/activatepython push_main.py 信誓旦旦的等待中，到点后却发现run.log一直都是空的，出现问题了。 错误排查 首先检查命令。 1~/XXX/start.sh &gt;&gt; ~/XXX/run.log 2&gt;&amp;1 没问题，正常输出追加log。 查看Crontab状态和执行日志。 123456# 查看Crontab状态service cron status...# 查看Crontab执行日志grep cron /var/log/syslog... 发现时间和本地时间不同，并没有执行命令，方便调试，这里我们调成和本地一样的东八区。 1234timedatectl set-timezone Asia/Shanghai# 重启系统日志和Crontab使其修改生效systemctl restart rsyslogservice crond restart 时区正确后查看执行日志发现找不到source命令，且找不到venv/bin/activate。 Crontab所用的/bin/sh不包含source命令，用.代替运行脚本即可。 找不到venv/bin/activate，是因为Crontab执行默认是在用户的根目录下，需要提前手动cd，在start.sh中添加cd ~/XXX/ 导出的log中文自动转码 Crontab执行的环境变量和用户不同导致的，在start.sh最顶部中添加export LANG=zh_CN.UTF-8导入即可。 修正后的start.sh 1234export LANG=zh_CN.UTF-8cd ~/XXX. venv/bin/activatepython push_main.py 总结Crontab执行环境和用户执行环境差的有点多，很零碎的参考，记得快忘的也快。","link":"/2022/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Crontab%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Backup","slug":"Backup","link":"/tags/Backup/"},{"name":"Caddy","slug":"Caddy","link":"/tags/Caddy/"},{"name":"Typecho","slug":"Typecho","link":"/tags/Typecho/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Sony","slug":"Sony","link":"/tags/Sony/"},{"name":"Flash","slug":"Flash","link":"/tags/Flash/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Actions","slug":"Github-Actions","link":"/tags/Github-Actions/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Domain","slug":"Domain","link":"/tags/Domain/"},{"name":"Cloudflare","slug":"Cloudflare","link":"/tags/Cloudflare/"},{"name":"AirtestIDE","slug":"AirtestIDE","link":"/tags/AirtestIDE/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Script","slug":"Script","link":"/tags/Script/"},{"name":"OPS","slug":"OPS","link":"/tags/OPS/"},{"name":"Crontab","slug":"Crontab","link":"/tags/Crontab/"}],"categories":[{"name":"大杂烩","slug":"大杂烩","link":"/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"},{"name":"编程笔记","slug":"编程笔记","link":"/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]}