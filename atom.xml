<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>☾ Yuk的部落格</title>
  <icon>https://blog.yuk7.com/icon.png</icon>
  <subtitle>在水果摊上画画</subtitle>
  <link href="https://blog.yuk7.com/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.yuk7.com/"/>
  <updated>2021-12-02T13:59:12.621Z</updated>
  <id>https://blog.yuk7.com/</id>
  
  <author>
    <name>Yuk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>脚本助手：云手机上跑脚本的好伙伴</title>
    <link href="https://blog.yuk7.com/2021/11/25/%E8%84%9A%E6%9C%AC%E5%8A%A9%E6%89%8B%EF%BC%9A%E4%B8%80%E6%AC%BE%E7%9B%91%E6%8E%A7%E4%BA%91%E6%89%8B%E6%9C%BA%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E7%9A%84app/"/>
    <id>https://blog.yuk7.com/2021/11/25/%E8%84%9A%E6%9C%AC%E5%8A%A9%E6%89%8B%EF%BC%9A%E4%B8%80%E6%AC%BE%E7%9B%91%E6%8E%A7%E4%BA%91%E6%89%8B%E6%9C%BA%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E7%9A%84app/</id>
    <published>2021-11-25T15:30:53.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>书接上篇文章的刷初始，即使自己写了脚本简化了工作量，但是这游戏爆率实在难顶，一个好开局遥遥无期，凑巧在群里看到一些云手机里已经提供了对应的脚本，于是租了几个来刷一刷试试，效果确实好很多，效率也翻倍了。</p><p>可是一个新的需求出现了，当脚本卡住或刷出满足设定要求的时候会自动停下，我想要第一时间知道，而不是自己手动隔一段时间去查看其状态。</p><p>实现需求很简单，隔一段时间截图比对就行，通知就用最实用的发邮件。</p><p>基于 <a href="https://github.com/nladuo/PyAndroidControl">PyAndroidControl</a> 这个项目俺写了ScriptAssistan【脚本助手】这个app，<a href="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111251521145.apk">点击下载</a> </p><p>服务端我这边设置的是每五分钟检测一次，抽空扔Github上，到时候也可以自行搭建</p><p>图标长这样<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111251458181.png" width="100px" height="100px" alt="图标" align=center/></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>简单做了个图，大概如下图所示，基本大架构没怎么变。<br>主要新增了些Server端的处理逻辑，安卓端规范POST请求以及权限使用的优化。<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111242226139.png" alt="架构图"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>制作了个gif以便于直观展示，悬浮窗控制监控是否开启，软件需要root权限。<br> <img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111251501224.gif" width="360px" height="720px" alt="演示gif" align=center/></p><p>软件第一栏填写服务端地址，可以直接用我的<code>http://sa.yuk7.com:1024</code>，每五分钟检测一次。<br>第二栏填写该设备标示，用于在邮件提醒中多设备区分。<br>第三栏填写通知邮箱，第一栏如果用我提供的则会用inform # yuk7.com（#&gt;&gt;@） 发送提醒邮件，不要屏蔽即可。</p><p>邮件提醒效果展示<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111251518892.png" alt="邮件提醒"></p><h2 id="开发札记"><a href="#开发札记" class="headerlink" title="开发札记"></a>开发札记</h2><h3 id="广为流传的错误代码"><a href="#广为流传的错误代码" class="headerlink" title="广为流传的错误代码"></a>广为流传的错误代码</h3><p>Python中实现图像对比发现很多都是用 <a href="https://www.cnblogs.com/botoo/p/8416315.html">这篇博客中的方法</a> 核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageChops <br>image_one = Image.<span class="hljs-built_in">open</span>(path_one)<br>image_two = Image.<span class="hljs-built_in">open</span>(path_two)<br>diff = ImageChops.difference(image_one, image_two)<br></code></pre></div></td></tr></table></figure><p>然而这广为抄袭到处转载的代码，实际上是错误的，大部分情况下不管怎么判断都会认定是相同的一张图，需要改成：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">...<br>image_one = Image.<span class="hljs-built_in">open</span>(path_one).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>) <br>image_two = Image.<span class="hljs-built_in">open</span>(path_two).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>...<br></code></pre></div></td></tr></table></figure><p>类似的<a href="https://stackoverflow.com/questions/61812374/imagechops-difference-not-working-with-simple-png-images">Stackoverflow</a>也有讨论，大概是原方法是通过有无像素来判断是否为同一张图。而并非判断像素颜色。</p><p>PS：Google这简中搜索质量属实不行，这几个月内容农场仍在泛滥，简中一搜一大堆XX知识网在首页，这里分享一篇专门介绍和应对内容农场的文章 <a href="https://sspai.com/post/69407">清理「内容农场」，还你清爽的 Google 中文搜索体验</a> 。</p><p>Google对简中确实缺少重视，搜索用英文体验更好，麻了，以后试试英文写写博客？笑。</p><h3 id="变量命名再也不纠结"><a href="#变量命名再也不纠结" class="headerlink" title="变量命名再也不纠结"></a>变量命名再也不纠结</h3><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111251054840.jpg" alt="CODELF主页上的图"><br><a href="https://unbug.github.io/codelf/">CODELF</a> 这个网站可以让你查询单词来看到GitHub上同行们都是怎么命名的，挺有意思。</p><h3 id="Ubuntu部署Flask-WSGI"><a href="#Ubuntu部署Flask-WSGI" class="headerlink" title="Ubuntu部署Flask WSGI"></a>Ubuntu部署Flask WSGI</h3><p>这里只简单提及一些关键点，日后会专门写一篇详细的</p><p>如果pip安装Gevent时编译失败，则安装以下组件即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install python3 python-dev python3-dev \<br>     build-essential libssl-dev libffi-dev \<br>     libxml2-dev libxslt1-dev zlib1g-dev \<br></code></pre></div></td></tr></table></figure><p>这里WSGI用的是Gunicorn和Gevent的组合 使用Supervisor管理进程</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># /etc/supervisor/conf.d/ScriptAssistant.conf</span><br>[program:ScriptAssistant]<br>command=/home/ubuntu/ScriptAssistant/venv/<span class="hljs-built_in">bin</span>/gunicorn -w <span class="hljs-number">4</span> -b <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2333</span> -k gevent wsgi:app<br>directory=/home/ubuntu/ScriptAssistant/<br>autorestart = true<br>startsecs = <span class="hljs-number">5</span><br>startretries = <span class="hljs-number">3</span><br>user = root<br>nodaemon = false<br></code></pre></div></td></tr></table></figure><p>配置nginx开机自启</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> nginx<br></code></pre></div></td></tr></table></figure><p>添加每天零点删除screenshots文件夹脚本clean_screenshots.sh</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># ~/ScriptAssistant/clean_screenshots.sh</span><br>find . -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;screenshots&quot;</span> -<span class="hljs-built_in">exec</span> rm -rf &#123;&#125; \;<br>chmod u+x ./clean_screenshots.sh    <span class="hljs-comment"># 配置可执行</span><br>crontab -e<br>0 0 * * *  ~/ScriptAssistant/clean_screenshots.sh &gt; /dev/null 2&gt;&amp;1 <span class="hljs-comment"># 每天零点执行</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个对比截图来检测云手机有没有卡住的小玩意。</summary>
    
    
    
    <category term="编程笔记" scheme="https://blog.yuk7.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://blog.yuk7.com/tags/Android/"/>
    
    <category term="Flask" scheme="https://blog.yuk7.com/tags/Flask/"/>
    
    <category term="Python" scheme="https://blog.yuk7.com/tags/Python/"/>
    
    <category term="Script" scheme="https://blog.yuk7.com/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>使用AirtestIDE和iOS-Tagent实现iOS端自动化脚本</title>
    <link href="https://blog.yuk7.com/2021/11/13/%E4%BD%BF%E7%94%A8AirtestIDE%E5%92%8CiOS-Tagent%E5%AE%9E%E7%8E%B0iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <id>https://blog.yuk7.com/2021/11/13/%E4%BD%BF%E7%94%A8AirtestIDE%E5%92%8CiOS-Tagent%E5%AE%9E%E7%8E%B0iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</id>
    <published>2021-11-13T12:00:24.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<p>先前写过公主连接农场脚本，也写过昆特牌脚本，但还没有在iOS上实现过类似的自动化脚本，凑巧最近在蝗9号开服的碧蓝档案，遂尝试一番，Xcode上用网易开发的AirtestIDE和配套的iOS-Tagent。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>iPadOS版本：14.2<br>macOS版本：10.15.7<br>Xcode版本：12.3<br><a href="https://github.com/AirtestProject/iOS-Tagent">iOS-Tagent</a><br><a href="https://airtest.netease.com/">Airtest IDE 1.2.12</a><br>不需要Apple开发者账号，普通的Apple ID就行。</p><p>这里需要注意的是Xcode版本和你要操作设备的iOS和macOS系统要匹配，这里俺找到了一个<a href="https://xcodereleases.com/">好网站</a>，可以看到Xcode支持的的iOS SDK版本，以及最低支持macOS版本，同时支持下载。<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131029988.png" alt="xcodereleases.com"> 如果你下载好的Airtest IDE若在使用中出现闪退或异常问题，可以使用命令行终端来打开应用：</p><p>输入 <code>$ cd /Applications</code> 进入应用程序文件夹，</p><p>运行指令<code>$ ./AirtestIDE.app/Contents/MacOS/AirtestIDE</code> 即可打开AirtestIDE</p><h3 id="安装并测试WebDriverAgent"><a href="#安装并测试WebDriverAgent" class="headerlink" title="安装并测试WebDriverAgent"></a>安装并测试WebDriverAgent</h3><ol><li> 用Xcode打开<code>WebDriverAgent.xcodeproj</code>，并将iOS设备用数据线连接电脑，并在弹窗中信任</li></ol><p><img src="https://i.loli.net/2021/11/30/7m1AxirjvJXugwE.png" alt="用Xcode打开"></p><ol start="2"><li> 在Xcode顶部<code>product &gt;&gt; Destination &gt;&gt; 选择你的iOS设备</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131040657.png" alt="选择iOS设备"></p><ol start="3"><li>添加证书，按照下图的路径在<code>Signing &amp; Capabilities</code> 下的Team中添加登陆自己的Apple ID</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131044713.png" alt="登陆添加证书"></p><ol start="4"><li> 修改配置，这里我们需要修改两个地方。</li></ol><p>先是<code>Product Bundle Identifier</code>，这里要求是唯一的，会进行联网检查，通常就是自己域名反写加项目名<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131055996.png" alt="修改唯一值"> 第二个是<code>Validate Workspace</code>，改成Yes <strong>这一步网上很多都没写，导致后面报错运行不起来</strong><br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131051232.png" alt="修改Validate Workspace"></p><ol start="5"><li> 启动 command+U运行Test</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131056820.png" alt="启动"> 然后你会发现iOS设备上会多出来个WebDriverAgentRunner，但是启动不起来，此时你需要去设置里信任一下才能正常工作 设置 -&gt; 通用 -&gt; 描述文件与设备管理 ，对应用WebDriverAgentRunner进行信任<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131058208.png" alt="新增app图标"> 接着再运行一次Test，点击左下角显示日志，看到输出如下http之类的就代表成功了<br><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131103606.png" alt="显示日志"> 至此，Xcode相关操作已经结束</p><h3 id="使用iproxy映射端口"><a href="#使用iproxy映射端口" class="headerlink" title="使用iproxy映射端口"></a>使用iproxy映射端口</h3><p>这里我们直接用Homebrew安装即可，没安装的可以参考这篇<a href="https://cloud.tencent.com/developer/article/1759415">文章</a> </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install libimobiledevice --HEAD<br>iproxy 8100 8100<br></code></pre></div></td></tr></table></figure><p>此时我们用浏览器访问<code>http://127.0.0.1:8100/status</code> ，如果访问成功并且可以看到一些json格式的手机信息，即表示启动成功。</p><p>同时你也可以试着访问一下<code>http://127.0.0.1:8100/inspector</code>，正常应该是可以看到iOS设备的投屏，看不到也没关系，可能是脚本没有安装完全导致的，并不会影响Airtest IDE中的投屏，所以咱们也不用管它。</p><h3 id="Airtest-IDE连接"><a href="#Airtest-IDE连接" class="headerlink" title="Airtest IDE连接"></a>Airtest IDE连接</h3><p>直接输入127.0.0.1:8100 连接，看到iOS设备投屏就可以开始编写脚本了。</p><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131127605.png" alt="Link Start！"></p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>俺这里只是用来刷初始过新手教程的，所以基本上没啥难度，只要跟着教程流程点就可以了 代码就只用到了touch,wait,sleep，复杂流程基本没有。</p><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/202111131132983.png" alt="代码"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次尝试重点不是在编写脚本上，而是简单走了遍iOS的自动化测试流程，不过Airtest IDE用来写一些脚本确实很方便，只是奈何并没有好点的windows设备，不然多开跑脚本效率会高很多。</p><p>ps：碧蓝档案的初始真难出货， 淘宝上大多都是科技刷，不推荐购买。</p>]]></content>
    
    
    <summary type="html">IOS上自动化脚本环境搭建也没那么难嘛，不过不能多开是痛点。</summary>
    
    
    
    <category term="编程笔记" scheme="https://blog.yuk7.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://blog.yuk7.com/tags/Python/"/>
    
    <category term="AirtestIDE" scheme="https://blog.yuk7.com/tags/AirtestIDE/"/>
    
    <category term="iOS" scheme="https://blog.yuk7.com/tags/iOS/"/>
    
    <category term="Script" scheme="https://blog.yuk7.com/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>Flask数据库笔记</title>
    <link href="https://blog.yuk7.com/2020/02/02/Flask%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.yuk7.com/2020/02/02/Flask%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-02T23:43:00.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>想了想，整体笔记这个表述还是太过于笼统了，单独拎出来也方便查询复盘。<br>这里我们只是涉及到Flask-SQLAlchemy的使用层次上，深入的架构关系处理按下不表。<br>以下内容参考摘抄于《Flask+Web开发实战》，是本好书，感谢作者李辉。</p><h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; pip install flask-sqlclchemy<br></code></pre></div></td></tr></table></figure><h3 id="扩展的初始化"><a href="#扩展的初始化" class="headerlink" title="扩展的初始化:"></a>扩展的初始化:</h3><p>实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序实例app，完成。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br>app = Flask(__name__)<br>db = SQLAlchemy(app)<br></code></pre></div></td></tr></table></figure><h2 id="连接数据库服务器"><a href="#连接数据库服务器" class="headerlink" title="连接数据库服务器"></a>连接数据库服务器</h2><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/%E4%BD%BF%E7%94%A8Flask-SQLAlchemy%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%931.png" alt="各类数据库URI"></p><h3 id="配置SQLite数据库URI"><a href="#配置SQLite数据库URI" class="headerlink" title="配置SQLite数据库URI"></a>配置SQLite数据库URI</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br> ...<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = os.getenv(<span class="hljs-string">&#x27;DATABASE_URL&#x27;</span>, <span class="hljs-string">&#x27;sqlite:///&#x27;</span> + os.path.join(app.root_path, <span class="hljs-string">&#x27;db.sqlite3&#x27;</span>))<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br></code></pre></div></td></tr></table></figure><p>这里图方便用的就是SQLite，只需要提供文件路径即可[这里是app同路径下db.sqlite3]。</p><p>但在生产环境下更换到其他类型的DBMS时，数据库URL会包含敏感信息，所以这里优先从环境变量DATABASE_URL获取。</p><p>【注意不同操作系统下斜杆数不一致】所以也就玩具项目图方便用下，其他情况下还是用Mysql等更专业的吧。</p><h3 id="配置Mysql数据库URI"><a href="#配置Mysql数据库URI" class="headerlink" title="配置Mysql数据库URI"></a>配置Mysql数据库URI</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br> ...<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = os.getenv(<span class="hljs-string">&#x27;DATABASE_URL&#x27;</span>,<span class="hljs-string">&#x27;mysql://root:password@127.0.0.1:3306/database_name&#x27;</span>)<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br></code></pre></div></td></tr></table></figure><p>需要提前开启Mysql服务器以及创建好database_name。</p><p>安装并初始化Flask-SQLAlchemy后，启动程序时会看到命令行下有一行警告信息。<br>这是因为Flask-SQLAlchemy建议你设置SQLALCHEMY_TRACK_MODIFICATIONS 配置变量，这个配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事件通知系统。</p><p>这个配置键的默认值为None，如果没有特殊需要，我们可以把它设为 False来关闭警告信息:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br></code></pre></div></td></tr></table></figure><h2 id="定义数据库模型"><a href="#定义数据库模型" class="headerlink" title="定义数据库模型"></a>定义数据库模型</h2><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/Screen%20Shot%202020-02-22%20at%209.06.12%20AM.png" alt="数据库字段"></p><p>这里我就演示了下几个常用的</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br> ...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Note</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    author = db.Column(db.String(<span class="hljs-number">25</span>), nullable=<span class="hljs-literal">False</span>)<br>    created_time = db.Column(db.DateTime, default=datetime.now, nullable = <span class="hljs-literal">False</span>)<br>    body = db.Column(db.Text,default=<span class="hljs-string">&#x27;Write Something&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>默认情况下，Flask-SQLAlchemy会根据模型类的名称生成一个表名称，生成规则如下:<br>Message –&gt; message # 单个单词转换为小写<br>FooBar –&gt; foo_bar # 多个单词转换为小写并使用下划线分隔 Note类对应的表名称即note</p><p>如果你想自己指定表名称，可以通过定义 <code>__tablename__</code>属性来实现。</p><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>定义好模型后就可以直接创建了。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> click<br> ...<br><span class="hljs-meta">@app.cli.command()</span><br><span class="hljs-meta">@click.option(<span class="hljs-params"><span class="hljs-string">&#x27;--drop&#x27;</span>, is_flag=<span class="hljs-literal">True</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;Create after drop.&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initdb</span>(<span class="hljs-params">drop</span>):</span><br>    <span class="hljs-keyword">if</span> drop:<br>        click.confirm(<span class="hljs-string">&#x27;This operation will delete the database, do you want to continue?&#x27;</span>, abort=<span class="hljs-literal">True</span>)<br>        db.drop_all()<br>        click.echo(<span class="hljs-string">&#x27;Drop tables.&#x27;</span>)<br>    db.create_all()<br>    click.echo(<span class="hljs-string">&#x27;Initialized database.&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>这里自定义了个flask命令<code>flask initdb</code>，用click还添加了个<code>--drop</code>的参数。</p><p>但是我们这里为了让数据库中实际的表同步数据模型的变化【添加或删除字段，修改字段的名称和类型之类的】是直接暴力的db.drop_all()后再重新db.create_all()，会直接清空表中原有的数据，迁移表原有数据后文中写。</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>为了方便，接下来使用flask bash进行演示，在此之前我们先将自己定义的数据库模型类以及db手动传入到上下文中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 传入bash上下文</span><br><span class="hljs-meta">@app.bash_context_processor</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_bash_context</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(db=db, Note=Note)<br></code></pre></div></td></tr></table></figure><p>终端进入项目所在路径执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; flask initdb --drop<br>This operation will delete the database, <span class="hljs-keyword">do</span> you want to <span class="hljs-built_in">continue</span>? [y/N]: y<br>Drop tables.<br>Initialized database.<br>&gt; flask bash<br>Python 3.7.5 (default, Nov 29 2019, 17:17:51) <br>[Clang 11.0.0 (clang-1100.0.20.17)] on darwin<br>App: app [production]<br>Instance: /Users/Mosaic/Programming/Flask/instance<br>&gt;&gt;&gt;<br></code></pre></div></td></tr></table></figure><p>用上一小节的命令<code>flask initdb --drop</code>我们先同步好了模型表，然后进入<code>flask bash</code> 。</p><p>【<strong>下文中<code>&gt;&gt;&gt;</code>开头的都代表是在flask shell模式中</strong>】<br>增删改查。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>note1 = Note(body=<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>note2 = Note(body=<span class="hljs-string">&#x27;world&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.add(note1) <span class="hljs-comment"># 增</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.add(note2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit() <span class="hljs-comment"># 每次更改都要commit才能同步到数据库</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.delete(note1) <span class="hljs-comment"># 删</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit()<br><span class="hljs-meta">&gt;&gt;&gt; </span>note1.body = <span class="hljs-string">&#x27;giao!&#x27;</span> <span class="hljs-comment"># 改</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit()<br><span class="hljs-meta">&gt;&gt;&gt; </span>Note.query.filter_by(body=<span class="hljs-string">&#x27;giao!&#x27;</span>).first() == note1 <span class="hljs-comment"># 查</span><br><span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><p>一般来说，一个完整的查询遵循下面的模式: &lt;模型类&gt;.query.&lt;过滤方法&gt;.&lt;查询方法&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/Screen%20Shot%202020-02-22%20at%2010.53.04%20AM.png" alt="过滤器"> 和filter()方法相比，filter_by()方法更易于使用。</p><p>在filter_by() 方法中，你可以使用关键字表达式来指定过滤规则。更方便的是，你可以在这个过滤器中直接使用字段名称。</p><p>下面的示例使用filter_by()过滤器完成了同样的任务:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Note.query.filter_by(body=<span class="hljs-string">&#x27;SHAVE&#x27;</span>).first()<br><span class="hljs-comment"># 等价于 Note.query.filter(Note.body=&#x27;SHAVE&#x27;).first()</span><br></code></pre></div></td></tr></table></figure><p>其他的不一一举例了。</p><h2 id="建立模型之间几种基础的关系模式"><a href="#建立模型之间几种基础的关系模式" class="headerlink" title="建立模型之间几种基础的关系模式"></a>建立模型之间几种基础的关系模式</h2><h3 id="单向和双向关系"><a href="#单向和双向关系" class="headerlink" title="单向和双向关系"></a>单向和双向关系</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>(<span class="hljs-params">db.Model</span>):</span>    <br>  <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    name = db.Column(db.String(<span class="hljs-number">70</span>), unique=<span class="hljs-literal">True</span>)<br>    books = db.relationship(<span class="hljs-string">&#x27;Book&#x27;</span>, back_populates=<span class="hljs-string">&#x27;writer&#x27;</span>)<br>    <span class="hljs-comment"># books = db.relationship(&#x27;Book&#x27;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    title = db.Column(db.String(<span class="hljs-number">50</span>), index=<span class="hljs-literal">True</span>)<br>    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;writer.id&#x27;</span>))<br>    writer = db.relationship(<span class="hljs-string">&#x27;Writer&#x27;</span>, back_populates=<span class="hljs-string">&#x27;books&#x27;</span>)<br>    <span class="hljs-comment"># writer = db.relationship(&#x27;Writer&#x27;)    </span><br></code></pre></div></td></tr></table></figure><p>这里我们定义了两个模型，都定义了db.relationship relationship()。</p><p>函数的第一个参数为关系另一侧的模型名称，在Writer中它会告诉SQLAlchemy将Writer类与Book类建立关系。</p><p>如果db.relationship只被定义在Writer中，而Book中没有，就叫单向关系【只能从Writer查询到books，不能从Book方向查询自己的Writer】，两边都有就是双向关系【双方可以互查】。</p><p>而back_populates参数是用来连接两边的relationship的，值为对面关系名字，从而实现<strong>未commit之前</strong>两边关系的同步。</p><p>【例如删掉了Writer A的Book B，Book B的Writer A也会被同步删除】，但是不管加没加back_populates参数，commit之后两边关系总会同步好的【之所以加重<code>未commit之前</code>是因为自己一个个测试出来的…当初对back_populates这个参数有点疑惑坑，涉及到了后面的级联】</p><p>其他参数如下，不一一举例了，backref是隐式双向，不推荐，uselist可以用在一对一关系中，secondary用在多对多关系中。</p><p><img src="https://cdn.jsdelivr.net/gh/yuk7-0v0/wp_cdn_resources/picBed/Screen%20Shot%202020-02-22%20at%204.54.13%20PM.png" alt="各种参数"> </p><p>【下面几种关系都默认使用双向关系】</p><h3 id="一对多-多对一"><a href="#一对多-多对一" class="headerlink" title="一对多/多对一"></a>一对多/多对一</h3><p>定义关系的第一步是创建外键。外键是(foreign key)用来在A表存储B表的主键值以便和B表建立联系的关系字段。</p><p>因为外键只能存储单一数据(标量)，所以<strong>外键总是在“多”这一侧定义</strong>。</p><p>多本书属于同一个作者，所以我们需要为每本书添加外键存储作者的主键值以指向对应的作者。</p><p>在Book模型中，我们定义一 个writer_id字段作为外键:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">db.Model</span>):</span><br>  ...<br>writer_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;writer.id&#x27;</span>))<br></code></pre></div></td></tr></table></figure><p>这个字段使用db.ForeignKey类定义为外键，传入关系另一侧的表名和主键字段名，即writer.id。</p><p>实际的效果是将book表的writer_id的值限制为Writer表的id列的值。</p><p>它将用来存储Writer表中记录的主键值 再加上双向关系，一个一对多/多对一就完成了。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    name = db.Column(db.String(<span class="hljs-number">70</span>), unique=<span class="hljs-literal">True</span>)<br>    books = db.relationship(<span class="hljs-string">&#x27;Book&#x27;</span>, back_populates=<span class="hljs-string">&#x27;writer&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    title = db.Column(db.String(<span class="hljs-number">50</span>), index=<span class="hljs-literal">True</span>)<br>    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;writer.id&#x27;</span>)) <br>    writer = db.relationship(<span class="hljs-string">&#x27;Writer&#x27;</span>, back_populates=<span class="hljs-string">&#x27;books&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>当Writer查询books时，会返回所有Book.writer_id与Writer.id一致的Book【返回列表】，而当Book查询Writer时，会返回Writer.id与writer_id一致的Writer【返回单个值】。</p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一就是再一对多/多对一的基础上加上了个参数。</p><p>下面假设一个作者一生只写一本书，一本书也只能有一个作者</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    name = db.Column(db.String(<span class="hljs-number">70</span>), unique=<span class="hljs-literal">True</span>)<br>    book = db.relationship(<span class="hljs-string">&#x27;Book&#x27;</span>, back_populates=<span class="hljs-string">&#x27;writer&#x27;</span>, uselist=<span class="hljs-literal">False</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    title = db.Column(db.String(<span class="hljs-number">50</span>), index=<span class="hljs-literal">True</span>)<br>    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;writer.id&#x27;</span>)) <br>    writer = db.relationship(<span class="hljs-string">&#x27;Writer&#x27;</span>, back_populates=<span class="hljs-string">&#x27;books&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>在Writer的relationship加上了uselist=False，这将表示只能返回单个值了。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>需要额外定义一个表来处理两边的外键对应关系。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">association_table = db.Table(<span class="hljs-string">&#x27;association&#x27;</span>,db.Column(<span class="hljs-string">&#x27;student_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;student.id&#x27;</span>)),db.Column(<span class="hljs-string">&#x27;teacher_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;teacher.id&#x27;</span>))<br>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>) <br>    name = db.Column(db.String(<span class="hljs-number">70</span>), unique=<span class="hljs-literal">True</span>) <br>    grade = db.Column(db.String(<span class="hljs-number">20</span>))<br>    teachers = db.relationship(<span class="hljs-string">&#x27;Teacher&#x27;</span>,<br>    secondary=association_table, back_populates=<span class="hljs-string">&#x27;students&#x27;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>) <br>    name = db.Column(db.String(<span class="hljs-number">70</span>), unique=<span class="hljs-literal">True</span>) <br>    office = db.Column(db.String(<span class="hljs-number">20</span>))<br></code></pre></div></td></tr></table></figure><h2 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h2><p>我们使用Flask-Migrate来实现保留数据更改表。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; pip install flask-migrate<br></code></pre></div></td></tr></table></figure><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br><span class="hljs-keyword">from</span> flask_migrate <span class="hljs-keyword">import</span> Migrate<br>app = Flask(__name__)<br> ...<br>db = SQLAlchemy(app)<br>migrate = Migrate(app, db) <span class="hljs-comment"># 在db对象创建后调用</span><br></code></pre></div></td></tr></table></figure><h3 id="创建迁移环境"><a href="#创建迁移环境" class="headerlink" title="创建迁移环境"></a>创建迁移环境</h3><p>在开始迁移数据之前，需要先使用下面的命令创建一个迁移环境:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; flask db init<br></code></pre></div></td></tr></table></figure><h3 id="生成迁移脚本"><a href="#生成迁移脚本" class="headerlink" title="生成迁移脚本"></a>生成迁移脚本</h3><p>使用migrate子命令可以自动生成迁移脚本:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; flask db migrate -m <span class="hljs-string">&quot;add note timestamp&quot;</span><br>    ...<br>INFO [alembic.autogenerate.compare] Detected added column <span class="hljs-string">&#x27;message.timestamp</span><br><span class="hljs-string">Generating /Path/to/your/database/migrations/versions/c52a02014635_add note_timestamp.py ... done</span><br></code></pre></div></td></tr></table></figure><p>这条命令可以简单理解为在flask里对数据库(db)进行迁移(migrate)，-m 选项用来添加迁移备注信息。</p><p>从上面的输出信息我们可以看到，Alembic检测出了模型的变化:表note新添加了一个timestamp列，并且相应生成了一个迁移脚本 c52a02014635_add_note_timestamp.py<br>【迁移命令是由Alembic自动生成的，其中可能包含错误，所以有必要在生成后检查一下】</p><p>因为每一次迁移都会生成新的迁移脚本，而且Alembic为每一次迁移都生成了修订版本(revision)ID，所以数据库可以恢复到修改历史中的任一点。</p><p>正因为如此，迁移环境中的文件也要纳入版本控制。</p><p>有些复杂的操作无法实现自动迁移，这时可以使用revision命令手动创建迁移脚本。<br>这同样会生成一个迁移脚本，不过脚本中的upgrade()和downgrade()函数都是空的。</p><p>你需要使用Alembic提供的Operations对象指令在这两个函数中实现具体操作，具体可以访问Alembic官方文档查看。</p><h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><p>生成了迁移脚本后，使用upgrade子命令即可更新数据库:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&gt; flask db upgrade <br>...INFO [alembic.runtime.migration] Running upgrade -&gt; c52a02014635, add note timestamp<br></code></pre></div></td></tr></table></figure><p>如果还没有创建数据库和表，这个命令会自动创建；</p><p>如果已经创建，则会在不损坏数据的前提下执行更新。<br>如果你想回滚迁移，那么可以使用downgrade命令(降级)，它会撤销最后一 次迁移在数据库中的改动，这在开发时非常有用。</p><p>比如，当你执行upgrade命令后,发现某些地方出错了，这时就可以执行flask db downgrade命令进行回滚，删除对应的迁移脚本，重新生成迁移脚本后再进行更新(upgrade)。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有一些什么级联操作，事件监听之类的没有提到……，写笔记的时间比学习内容时间都要多是好事还是坏事，emmmmm，不过思路还是清晰了，管他呢~</p>]]></content>
    
    
    <summary type="html">笔记而已，温故而知新。</summary>
    
    
    
    <category term="编程笔记" scheme="https://blog.yuk7.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Flask" scheme="https://blog.yuk7.com/tags/Flask/"/>
    
    <category term="Python" scheme="https://blog.yuk7.com/tags/Python/"/>
    
    <category term="Database" scheme="https://blog.yuk7.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Python虚拟环境大杂烩</title>
    <link href="https://blog.yuk7.com/2019/11/29/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>https://blog.yuk7.com/2019/11/29/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2019-11-29T10:32:30.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2021年复盘，<code>Hatch</code>在写完这篇文章后就再也没有新的更新，看来还真不能乱立Flag，hhhh</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>距离上篇博客差了半年，很惭愧，因为促使自己写博客的动力之一就是接触了新东西，想记录下来，这大半年实在不太在状态，写了几篇文章发布后又删除了，好在最近感觉好了不少。</p><p>这个学期开始明显感觉校内网限速严重了许多，时不时还断连需要重新认证一下，体验很不好，尤其是用<code>Pipenv</code>安装一些包的时候，尽管知道安装慢很大一部分是网络的问题，但当我看到<code>Pipenv</code>安装报错时，也渐渐对<code>Pipenv</code>起了一些疑虑，有时当我创建一个新的虚拟环境需要很长时间，有时候又Locking很久……，那颗折腾的心又躁动了起来。</p><h2 id="为什么需要虚拟环境"><a href="#为什么需要虚拟环境" class="headerlink" title="为什么需要虚拟环境"></a>为什么需要虚拟环境</h2><p>防止各种项目冲突顺便方便的导出所有依赖，简单的例子就是A项目中需要的是<code>Django1.0</code>，而B项目中需要的是<code>Django2.0</code>，为了防止来回卸载安装，所以我们使用虚拟环境分别配置单独的运行环境</p><h2 id="虚拟环境大杂烩"><a href="#虚拟环境大杂烩" class="headerlink" title="虚拟环境大杂烩"></a>虚拟环境大杂烩</h2><p>光是Pycharm所支持的就有 <code>virtualenv</code> <code>Conda</code> <code>Pipenv</code>等等 以及看大佬推荐的<code>Poetry</code> <code>Conda</code> 最后还是选择了顺手的 <code>Hatch</code> </p><h2 id="选择哪种虚拟环境工具好"><a href="#选择哪种虚拟环境工具好" class="headerlink" title="选择哪种虚拟环境工具好"></a>选择哪种虚拟环境工具好</h2><p>先给出目前的个人结论：用回 <code>virtualenv</code>/<code>venv</code> 和 <code>pip</code>不一定是最方便的，但是至少更可靠 之前我一直都是用的<code>Pipenv</code>，说实在的除了偶尔<code>Creating</code>&amp;<code>Locking</code>慢了点，并没有遇到什么大问题，但当我看到 <a href="https://zhuanlan.zhihu.com/p/80478490">不要用 Pipenv</a> 改变了 ‘我用着舒服你那问题我没遇见就接着用下去’ 的想法。</p><p>其中最让我不能接受的就是打着官方暧昧关系进行宣传以及快一年没有新的 <code>releases</code> 。</p><p>既然已经有了换的心思，满怀希望的去尝试大佬推荐的 <code>Poetry</code> ，嗯官网界面很对我口味，结果正当我安装好初始化时现实又给我来了一巴掌。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">→ poetry init<br><br>This <span class="hljs-built_in">command</span> will guide you through creating your pyproject.toml config.<br><br>[UnicodeDecodeError]<br><span class="hljs-string">&#x27;ascii&#x27;</span> codec can<span class="hljs-string">&#x27;t decode byte 0xe8 in position 0: ordinal not in range(128</span><br><span class="hljs-string">)</span><br></code></pre></div></td></tr></table></figure><p>溜了溜了，连最基础的路径下创建文件都能整一个编码错误的项目我是更不敢用了，还是老办法吧。</p><h2 id="重回-virtualenv-和-pip-时代"><a href="#重回-virtualenv-和-pip-时代" class="headerlink" title="重回 virtualenv 和 pip 时代"></a>重回 virtualenv 和 pip 时代</h2><p>这里我还用到了<code>virtualenvwrapper</code>这个工具来简化<code>virtualenv</code>的操作</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">pip install virtualenv virtualenvwrapper<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bashbash"># 环境配置<br># 查看 virtualenvwrapper.sh 路径<br>$ which virtualenvwrapper.sh<br>/usr/local/bin/virtualenvwrapper.sh<br><br># 配置环境变量 (以后创建的环境目录都集中放在 $WORKON_HOME 目录下管理了)<br># 配置文件位置: ~/.bashrc (bash) 或 ~/.zshrc (zsh) (Linux/macOS（win自行搜索）)<br>export WORKON_HOME=$HOME/.virtualenvs<br>source /usr/local/bin/virtualenvwrapper.sh<br><br># 简化命令 ~/.zshrc (zsh)<br># which python  python3 得到-p后的参数值<br>alias mkv3=&#x27;mkvirtualenv -p /usr/local/bin/python3&#x27;<br>alias mkv2=&#x27;mkvirtualenv -p /usr/local/bin/python&#x27;<br>alias lsv=&#x27;lsvirtualenv&#x27;<br>alias rmv=&#x27;rmvirtualenv&#x27;<br>alias shv=&#x27;showvirtualenv&#x27;<br>alias dev=&#x27;deactivate&#x27;<br></code></pre></div></td></tr></table></figure><p>常用命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># workon  进入切换 环境</span><br>$ workon ENVNAME<br><br><span class="hljs-comment"># mkvirtualenv 创建环境</span><br>$ mkvirtualenv ENVNAME<br><br><span class="hljs-comment"># lsvirtualenv 展示环境列表</span><br>$ lsvirtualenv [-b] [-l] [-h]<br><br><span class="hljs-comment"># rmvirtualenv 删除环境</span><br>$ rmvirtualenv ENVNAME<br><br><span class="hljs-comment"># cpvirtualenv 复制环境</span><br>$ cpvirtualenv ENVNAME [TARGETENVNAME]<br><br><span class="hljs-comment"># allvirtualenv 所有环境运行命令 (比如安装包)</span><br>$ allvirtualenv <span class="hljs-built_in">command</span> with arguments<br>$ allvirtualenv pip install -U pip<br><br><span class="hljs-comment"># deactivate 退出当前环境</span><br>$ deactivate<br><br><span class="hljs-comment"># mkproject  创建项目</span><br>$ mkproject [-f--force] [-t template] [virtualenv_options] ENVNAME<br></code></pre></div></td></tr></table></figure><h2 id="六、发展中的Hatch-不支持Python2"><a href="#六、发展中的Hatch-不支持Python2" class="headerlink" title="六、发展中的Hatch(不支持Python2)"></a>六、发展中的Hatch(不支持Python2)</h2><p>就在我准备收尾时，突然发现了 <a href="https://github.com/ofek/hatch">Hatch</a> 这个项目，基于virtualenv 简单安装使用下来发现意外的很舒服，具体安装步骤见项目主页，这里简单回顾提及下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装virtualenv和Hatch</span><br>pip3 install virtualenv hatch<br><br><span class="hljs-comment"># 如果重启后hatch用不了那么可能是你没有配置好python的PATH</span><br><br><span class="hljs-comment"># 配置环境变量(Linux/macOS（win自行搜索）)</span><br><span class="hljs-comment"># 配置文件位置: ~/.bashrc (bash) 或 ~/.zshrc (zsh)</span><br>&gt; <span class="hljs-built_in">which</span> python3<br>    /usr/<span class="hljs-built_in">local</span>/Cellar/python/3.7.4/bin<br>&gt; <span class="hljs-built_in">export</span> PATH=/usr/<span class="hljs-built_in">local</span>/Cellar/python/3.7.4/bin:<span class="hljs-variable">$PATH</span><br></code></pre></div></td></tr></table></figure><p>常用命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有的虚拟环境（~/.virtualenvs）</span><br>hatch env -l<br><span class="hljs-comment"># 创建虚拟环境</span><br>hatch env envname<br><span class="hljs-comment"># 进入虚拟环境</span><br>hatch bash envname<br><span class="hljs-comment"># 删除虚拟环境</span><br>hatch shed -e envname<br><span class="hljs-comment"># 退出虚拟环境</span><br><span class="hljs-built_in">exit</span><br><span class="hljs-comment"># 列出所有以保存的pypath</span><br>hatch pypath -l<br><span class="hljs-comment"># 添加一个指向/usr/bin/python名字为py2的pypath</span><br>hatch pypath py2 /usr/bin/python<br><span class="hljs-comment"># 删除一个pypath</span><br>hatch shed -p py2<br><span class="hljs-comment"># 使用指定的pypath(这里是py2)作为虚拟环境的解释器</span><br>hatch env -py py2 old<br><br><span class="hljs-comment"># 简化命令 ~/.zshrc (zsh)</span><br><span class="hljs-built_in">alias</span> inv=<span class="hljs-string">&#x27;hatch bash&#x27;</span><br><span class="hljs-built_in">alias</span> lsv=<span class="hljs-string">&#x27;hatch env -l&#x27;</span><br><span class="hljs-built_in">alias</span> rmv=<span class="hljs-string">&#x27;hatch shed -e&#x27;</span><br></code></pre></div></td></tr></table></figure><p>目前上面这些功能其实和<code>virtualenv</code>差不多，但是项目主页上的TODO中有一行写到<code>python</code> - installs the desired version of Python. will work on each platform，这代表以后版本更新后也可以自由的像<code>Conda</code>那样创建虚拟环境的时候直接指定特定的<code>Python</code>版本。</p><p>（值得一提的是：之前我也尝试去用了下<code>Conda</code>来管理，但是他会和<code>pip</code>有一定冲突，而且如果用<code>Conda install</code>会有很多包找不到，在虚拟环境下安装<code>pip</code>又会多出几个额外的依赖，所以放弃了）</p><p>期待<code>Hatch</code>后续的更新，毕竟我切换<code>Python</code>版本还是用的少的。</p>]]></content>
    
    
    <summary type="html">在体验过Pipenv，Poetry，Conda等虚拟环境后，还是回归了virtualenv。</summary>
    
    
    
    <category term="编程笔记" scheme="https://blog.yuk7.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://blog.yuk7.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Sony Xperia XZ1(G8342)强刷笔记</title>
    <link href="https://blog.yuk7.com/2019/04/07/Sony%20Xperia%20XZ1(G8342)%E5%BC%BA%E5%88%B7%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.yuk7.com/2019/04/07/Sony%20Xperia%20XZ1(G8342)%E5%BC%BA%E5%88%B7%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-07T09:22:58.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019.06 卖了XZ1，换了iPhone8，配合MBP真香~ 不是同型号或者不是索尼手机的，本文并没有啥参考价值</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>由于2700mAh<strong>超大</strong>电池而且无root的XZ1在各类流氓面前不堪一击，为了摆脱一日二充的处境，咱只得解锁root了…带来的就是无法保修和没了OTA更新，且为了及时打上安全补丁不得不隔个月就得刷个机…</p><p>但是疏于记录…每次刷都会浪费很多时间，那就简单写下吧<br>已解锁BL锁</p><h2 id="刷机之前"><a href="#刷机之前" class="headerlink" title="刷机之前"></a>刷机之前</h2><p>备份以及刷机后的操作之前也写过一篇，可以直接拿来用 <a href="https://www.ratdis1.com/2018/11/18/android-backup-and-management/">Android软件数据备份以及管理优化</a> <strong>记得提前退出谷歌账号</strong></p><h2 id="一堆用得着的散东西"><a href="#一堆用得着的散东西" class="headerlink" title="一堆用得着的散东西"></a>一堆用得着的散东西</h2><p>以下的连接都是给的更新页，所以就不用担心旧版本什么的问题了</p><ul><li>  <a href="https://xpericheck.com/">XperiCheck</a> 很方便的查看各区域的固件更新情况</li><li>  <a href="https://forum.xda-developers.com/crossdevice-dev/sony/pc-xperifirm-xperia-firmware-downloader-t2834142">XperiFirm</a> 下载固件用的</li><li>  <a href="http://www.flashtool.net/downloads.php">Flashtool</a> 我只是用来安装驱动了</li><li>  <a href="https://forum.xda-developers.com/crossdevice-dev/sony/progress-newflasher-xperia-command-line-t3619426">Newflasher</a> 强刷命令行工具</li><li>  <a href="https://forum.xda-developers.com/xperia-xz1/development/recovery-twrp-3-2-1-t3727602/page12">TWRP</a> RECOVERY</li><li>  <a href="https://github.com/topjohnwu/Magisk/releases">Magisk</a> root权限管理</li><li>  <a href="https://github.com/shadowsocks/shadowsocks-android/releases">Shadowsocks</a> 上互联网恢复备份</li><li>  <a href="https://androidmtk.com/download-minimal-adb-and-fastboot-tool">Minimal ADB and Fastboot</a> =。=</li><li>  <a href="https://github.com/ElderDrivers/EdXposed">EdXposed</a> 安卓9上也能用的Xposed</li></ul><h2 id="动手惹"><a href="#动手惹" class="headerlink" title="动手惹"></a>动手惹</h2><p>先用<code>XperiFirm</code>下载最新的固件，众所周知的原因，请先设置好代理再下载…</p><blockquote><p>美版固件因为版权问题用不了指纹…亲身踩坑QAQ</p></blockquote><p>下载完后删除<code>simlock</code>文件，再将<code>Newflasher</code>解压到刚刚下好的固件同文件夹下，接着将手机彻底关机后按着音量下键来连接电脑，这样手机会进入绿灯模式，运行<code>Newflasher</code>，按照提示刷机完成即可，一般都是连续输入两次“n”。</p><p>之前没有刷过的应该是会缺少驱动出现问题…需要去找<code>Flashtool</code>的安装目录下的 <code>Flashtool-drivers.exe</code>（一般默认安装在 <code>C:\Flashtool\</code>) ，安装蓝 / 绿灯模式必须的两个驱动 <code>Flashmode Drivers</code> 和 <code>Fastboot Drivers</code>（就是第一个和第二个打勾）</p><p>如果是第一次安装估计会失败，需要<a href="https://jingyan.baidu.com/article/546ae185d818941148f28c6c.html">禁用驱动数字签名</a>后再进行安装。</p><p>驱动安装好后就可以继续在绿灯模式下用<code>Newflasher</code>强刷系统了。</p><p>强刷完系统后开机去开发者模式中打开USB调试后连接电脑，到<code>Minimal ADB and Fastboot</code>安装目录下运行<code>cmd-here.exe</code>并且将之前下载好的TWRP.img文件放进来，按如下命令操作即可</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">adb devices<br>adb reboot bootloader<br>fastboot devices<br>fastboot flash recovery TWRP.img<br>fastboot reboot<br></code></pre></div></td></tr></table></figure><p>完成后音量下键加开机键进入<code>recovery</code>刷入<code>Magisk</code>。</p><p>安装<code>EdXposed</code>之前需要刷好<a href="https://github.com/RikkaApps/Riru/releases">Riru-core</a>之类的，具体见<a href="https://github.com/ElderDrivers/EdXposed">EdXposed</a></p>]]></content>
    
    
    <summary type="html">记录下XZ1刷机过程。</summary>
    
    
    
    <category term="大杂烩" scheme="https://blog.yuk7.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="Android" scheme="https://blog.yuk7.com/tags/Android/"/>
    
    <category term="Sony" scheme="https://blog.yuk7.com/tags/Sony/"/>
    
    <category term="Flash" scheme="https://blog.yuk7.com/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>Caddy搭建Typecho并用脚本监控重启</title>
    <link href="https://blog.yuk7.com/2019/03/22/Caddy%E6%90%AD%E5%BB%BATypecho%E5%B9%B6%E7%94%A8%E8%84%9A%E6%9C%AC%E7%9B%91%E6%8E%A7%E9%87%8D%E5%90%AF/"/>
    <id>https://blog.yuk7.com/2019/03/22/Caddy%E6%90%AD%E5%BB%BATypecho%E5%B9%B6%E7%94%A8%E8%84%9A%E6%9C%AC%E7%9B%91%E6%8E%A7%E9%87%8D%E5%90%AF/</id>
    <published>2019-03-22T08:50:00.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>2019-03-11，换成了香港服务器，完善重构一下文章，新增了caddy异常监控脚本</strong></p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>继重装macOS和Android后，咱终于也把自己最不熟悉的服务器给重装了，服务商和主题也换了，特此记录下，以备不时再用=。=，也希望能帮到各位吧。</p><p>一直以来，我都是使用Nginx + Mysql的组合，使用Let’s Encrypt的SSL配合脚本自动续期，每次都要折腾不少时间… </p><p>开始之所以去尝试Caddy就是被大佬安利，看上了它操作简单去的，本体更是简单到只有一个文件，用 Go 写的 Web 服务器，配置简洁，能一键开启并续期 HTTPS (Let’s Encrypt)，省事多了啊，官网还有不少插件可以安装，分分钟即可搭建好个博客或者文件管理 操作系统为<code>Ubuntu 18.04 LTS</code>。</p><h2 id="Typcho下载"><a href="#Typcho下载" class="headerlink" title="Typcho下载"></a>Typcho下载</h2><p>直接上命令，将路径<code>/var/www/blog.yuk7.com</code>修改即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mkdir /var/www/blog.yuk7.com &amp;&amp; <span class="hljs-built_in">cd</span> /var/www/blog.yuk7.com<br><span class="hljs-comment"># 下载开发版</span><br>wget http://typecho.org/build.tar.gz<br>tar -zxvf build.tar.gz<br><span class="hljs-built_in">cd</span> build<br>mv * ../<br>sudo chown -R www-data:www-data /var/www<br></code></pre></div></td></tr></table></figure><h2 id="安装PHP7-2和Sqlite-3"><a href="#安装PHP7-2和Sqlite-3" class="headerlink" title="安装PHP7.2和Sqlite 3"></a>安装PHP7.2和Sqlite 3</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#更新系统</span><br>apt-get update -y<br><span class="hljs-comment">#安装PHP 7和Sqlite 3</span><br>apt-get install php7.2-cgi php7.2-fpm php7.2-curl php7.2-gd php7.2-mbstring php7.2-xml php7.2-sqlite3 sqlite3 -y<br></code></pre></div></td></tr></table></figure><h2 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h2><h3 id="Caddy下载安装"><a href="#Caddy下载安装" class="headerlink" title="Caddy下载安装"></a>Caddy下载安装</h3><p>在<a href="https://caddyserver.com/download">官网</a>记下你要使用到的插件名字，然后添加到下面的代码末尾运行安装即可 咱这里搭建博客只用到了<code>http.cache</code>和<code>http.expires</code>插件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl https://getcaddy.com  bash -s personal<br><br><span class="hljs-comment"># 例如我要使用到http.cache和http.expires的插件，运行</span><br>curl https://getcaddy.com  bash -s personal http.cache,http.expires<br><br><span class="hljs-comment"># 安装后可以使用caddy -plugins来查看自己已安装的插件列表</span><br><span class="hljs-comment"># 如果安装后又想加个插件时重新运行以上命令添加新插件名称至末尾</span><br></code></pre></div></td></tr></table></figure><p>安装完成后，使用<code>which caddy</code>应该就会显示<code>/usr/local/bin/caddy</code>了</p><h3 id="Caddy配置文件-Caddyfile"><a href="#Caddy配置文件-Caddyfile" class="headerlink" title="Caddy配置文件(Caddyfile)"></a>Caddy配置文件(Caddyfile)</h3><p><strong>请直接参考<a href="https://doctoralien.gitbooks.io/caddyserver/caddyfilepei-zhi-wen-jian.html">这里</a>和<a href="https://caddyserver.com/docs">官方文档</a>!!!</strong> 以下是我的配置，如果你是按照我上面的操作的话，大概只需要更改为自己的路径和域名，以及邮箱，保存为<code>/etc/caddy/Caddyfile</code></p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx">yuk7.com, www.yuk7.<span class="hljs-section">com</span> &#123;<br>    <span class="hljs-attribute">redir</span> https://www.yuk7.com&#123;url&#125;<br>&#125;<br>https://www.yuk7.com, https://blog.yuk7.<span class="hljs-section">com</span> &#123;<br>    <span class="hljs-comment"># 如果不需要记录log也可以直接删掉这一行</span><br>    <span class="hljs-attribute">log</span> / /var/log/caddy/blog.yuk7.com.log <span class="hljs-string">&quot;&#123;remote&#125; &#123;when&#125; &#123;method&#125; &#123;uri&#125; &#123;proto&#125; &#123;status&#125; &#123;size&#125; &#123;&gt;User-Agent&#125; &#123;latency&#125;&quot;</span><br>    cache<br>    gzip &#123;<br>        <span class="hljs-attribute">level</span> <span class="hljs-number">4</span><br>    &#125;<br>    tls admin@yuk7.com<br>    header / Strict-Transport-Security <span class="hljs-string">&quot;max-age=31536000&quot;</span><br>    expires &#123;<br>         <span class="hljs-attribute">match</span> .css$ <span class="hljs-number">1m</span><br>         match .js$ <span class="hljs-number">1m</span><br>         match .png$ <span class="hljs-number">1m</span><br>         match .jpg$ <span class="hljs-number">1m</span><br>    &#125;<br>    root /var/www/blog.yuk7.com<br>    fastcgi / /run/php/php7.<span class="hljs-number">2</span>-fpm.sock php<br>    rewrite &#123;<br>        <span class="hljs-section">if</span> &#123;path&#125; <span class="hljs-attribute">not_match</span><span class="hljs-regexp"> ^\/admin</span><br>        to &#123;path&#125; &#123;path&#125;/ /index.php?&#123;query&#125;<br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中使用到的<code>cache</code>需要提前安装好<code>http.cache</code>插件，<code>expires</code>也需要<code>http.expires</code>插件。</p><p>log文件操作</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /var/<span class="hljs-built_in">log</span>/caddy/blog.yuk7.com.log <span class="hljs-comment"># 新建log文件，vim用shift+z+z即可快速保存退出</span><br>chown www-data:www-data /var/<span class="hljs-built_in">log</span>/caddy/blog.yuk7.com.log <span class="hljs-comment"># 配置权限</span><br>systemctl reload caddy.service <span class="hljs-comment"># 重载</span><br></code></pre></div></td></tr></table></figure><h3 id="Caddy开机自启"><a href="#Caddy开机自启" class="headerlink" title="Caddy开机自启"></a>Caddy开机自启</h3><p>这里我们选择使用<code>systemd</code>实现 先去下载官方提供的<a href="https://github.com/mholt/caddy/blob/master/dist/init/linux-systemd/caddy.service">caddy.service</a>到/etc/systemd/system/。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service<br></code></pre></div></td></tr></table></figure><p>脚本里面用到了几个文件和文件夹需要我们自己手动创建，当然你也可以自己更改目录 <code>/etc/caddy</code> 放 Caddy 的配置文件，<code>/etc/ssl/caddy</code> 放证书，<code>/var/www</code> 是默认的网站目录。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo mkdir /etc/caddy /etc/ssl/caddy /var/www<br>sudo chown -R root:www-data /etc/caddy<br>sudo chown -R www-data:root /etc/ssl/caddy<br>sudo chown www-data:www-data /var/www<br>sudo chmod 0770 /etc/ssl/caddy<br>sudo touch /etc/caddy/Caddyfile<br></code></pre></div></td></tr></table></figure><p>让 Caddy 开机自启</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> caddy.service<br></code></pre></div></td></tr></table></figure><p>接着可以重启运行<code>ps -ef grep caddy</code>看看是否是否起作用。</p><p>如果没有使用<code>systemctl status caddy.service</code>查看报错，一般都是什么文件权限之类的小问题 <code>Caddy</code>的部分到此为止了。</p><p>接下来就是紧张刺激的安装<code>Typecho</code>了 然后浏览器打开你的域名/IP，不出意外就会见到Typecho的安装界面了，简单设置几个密码后，博客就搭建好了。</p><h2 id="脚本监控caddy"><a href="#脚本监控caddy" class="headerlink" title="脚本监控caddy"></a>脚本监控caddy</h2><p>之前遇到过几次caddy挂了的情况，手动重启一下就好了，但是这事还是扔给脚本去做吧~</p><p>以下脚本可以直接套用，只要把21行中的域名改成自己的即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br>host_dir=<span class="hljs-string">&quot;/root/&quot;</span>                                       <span class="hljs-comment"># 当前用户根目录</span><br>proc_name=<span class="hljs-string">&quot;caddy&quot;</span>                                       <span class="hljs-comment"># 进程名</span><br>file_name=<span class="hljs-string">&quot;restart_caddy.log&quot;</span>                           <span class="hljs-comment"># 日志文件</span><br>pid=0<br><br>proc_num()                                              <span class="hljs-comment"># 计算进程数</span><br>&#123;<br>    num=`ps -ef  grep <span class="hljs-variable">$proc_name</span>  grep -v grep  wc -l`<br>    <span class="hljs-built_in">return</span> <span class="hljs-variable">$num</span><br>&#125;<br><br>proc_id()                                               <span class="hljs-comment"># 进程号</span><br>&#123;<br>    pid=`ps -ef  grep <span class="hljs-variable">$proc_name</span>  grep -v grep  awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>&#125;<br><span class="hljs-comment"># 通过curl模拟登录获取http_code,模拟登录参数仅供参考</span><br><span class="hljs-comment"># 如果只需要判断某页面的状态可使用curl -I -s -w &quot;%&#123;http_code&#125;&quot; -o /dev/null http://www.baidu.com/ 直接获取即可</span><br><span class="hljs-comment"># http_code=`curl -I -s -w &quot;%&#123;http_code&#125;&quot; -o -d &quot;userKey=admin&amp;pass=c9127e832b41a&quot; /dev/null  http://portal.ly-sky.com/login.do?login=  head -n 1  cut -d$&#x27; &#x27; -f2`</span><br>http_code=`curl -I -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> -o /dev/null https://www.yuk7.com/`<br><br>proc_num<br>number=$?<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$number</span> -eq 0 ]][[ <span class="hljs-variable">$http_code</span> -ne 200 ]] <span class="hljs-comment"># 判断进程是否存在,页面状态是否是200</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># nohup ./run.sh&gt;../logs/urp.log 2&gt;&amp;1 &amp;    # 重启进程的命令，请相应修改</span><br>    <span class="hljs-comment"># nohup /usr/local/bin/caddy -log stdout -agree=true -conf=/etc/caddy/Caddyfile -root=/var/tmp -quic &amp;</span><br>    systemctl restart caddy.service<br>    sleep 3                                  <span class="hljs-comment">#延迟3秒是为了确保进程已正常启动并方便获取pid，否则有可能获取不到pid</span><br>    proc_id                                         <span class="hljs-comment"># 获取新进程号</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$pid</span>, `date` &gt;&gt; $host_dir<span class="hljs-variable">$file_name</span>     <span class="hljs-comment"># 将新进程号和重启时间记录</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p>修改权限并设置定时运行</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod 700 monitor_caddy.sh<br>crontab -e <span class="hljs-comment"># 加入下面这一行即可</span><br>*/5 * * * * /root/monitor_caddy.sh<br></code></pre></div></td></tr></table></figure><p>手动测试监控是否正常</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl stop caddy.service<br>./monitor_caddy.sh<br>cat restart_caddy.log <span class="hljs-comment"># 如果有内容则代表脚本正常</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Caddy</code>的配置的确很简单，配合<code>PHP 7.2</code>和<code>Sqlite 3</code>总共占的内存比使用<code>Nginx+PHP 7.2+Mysql</code>小了不少，性能差距咱也没有感觉有啥差，吹爆~</p>]]></content>
    
    
    <summary type="html">Caddy配置易上手，写了个脚本监控Caddy并重启。</summary>
    
    
    
    <category term="编程笔记" scheme="https://blog.yuk7.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Caddy" scheme="https://blog.yuk7.com/tags/Caddy/"/>
    
    <category term="Typecho" scheme="https://blog.yuk7.com/tags/Typecho/"/>
    
    <category term="Web" scheme="https://blog.yuk7.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Android软件数据备份以及管理优化</title>
    <link href="https://blog.yuk7.com/2018/11/08/Android%E8%BD%AF%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%BB%A5%E5%8F%8A%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.yuk7.com/2018/11/08/Android%E8%BD%AF%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%BB%A5%E5%8F%8A%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/</id>
    <published>2018-11-08T00:15:00.000Z</published>
    <updated>2021-12-02T13:59:12.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019.06 卖了XZ1，换了iPhone8，配合MacBook Pro真香~ 下面的大部分操作需要root</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近有些力不从心，重装macOS后又得重装Android(最近Sony终于咕咕咕的更新了安卓P)，服务器也都重装，因为有点系统洁癖。</p><p>这篇文章下我总结下安卓重装后的一些操作，会涉及到刷机前的备份准备以及刷机后系统的管理优化，希望对你有所帮助。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>备份是个好习惯，即使不刷机定时备份也是很重要的，备份一般包括App和App的数据，短信联系人，各种系统设置之类的，在这里我们只考虑备份App和App的数据的情况 在备份之前我们先对安卓下软件数据进行了解。</p><h3 id="备份原理"><a href="#备份原理" class="headerlink" title="备份原理"></a>备份原理</h3><p>在Android中的APK是<code>Android Package</code>的缩写，即Android安装包，其实就是一种压缩文件，安装软件时会自动把APK移动到<code>/data/app/</code>下，解压并把dex文件保存到<code>/data/dalvik-cache/</code>目录，接着在<code>/data/data/</code>目录下创建对应的应用数据目录。</p><p><code>/data/app/</code>这个目录下都是第三方软件，而系统软件的APK存储在了<code>/system/app/</code>下</p><p>提下<code>/system/app/</code> 和<code>/data/app/</code>的区别</p><ul><li>  <code>/data/app/</code>下的 普通用户可以卸载，<code>/system/app/</code>下的 只能root后删除。</li><li>  <code>/data/app/</code>下的软件即使静默也可以收到各种广播信息，<code>/system/app/</code>下的就不能。</li></ul><p>软件的私有数据大部分都存放在<code>/data/data/</code>和<code>/storage/emulated/0/Android/data/</code>下。</p><p>除了这两个有些大型游戏往往还会有个<code>/storage/emulated/0/Android/obb/</code>，OBB文件(Opaque Binary Blob)是安卓游戏通用数据包，存的都是游戏中所用到的资源，对于有些游戏会将OBB解包<code>/storage/emulated/0/Android/data/</code>目录下，但是也有直接读取不解包的。</p><h3 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h3><p>有了以上的知识背景后我们就可以手动对应用进行备份了，不过这样不够优雅，手动复制打包移动这些操作早就有了很多自动化的软件了。</p><p>在这里我们使用钛备份进行各种备份和还原操作，具体的软件操作就不多说了，虽然界面万年不变但是还是比较容易上手的。</p><p>分析下钛备份生成的备份文件，我们会发现当备份一个App以及数据后会生成三个文件，一个文件以<code>.properties</code>结尾，里面记录了一些备份的系统环境和备份软件的版本号之类的信息，给以后还原加载验证用的，另外两个都是<code>gz</code>格式的压缩包，其中一个中含有APK，另一个里面还是个压缩包，压缩着该软件的各种数据，就是上文所提及到的<code>/data/各种文件</code>。</p><p>钛备份默认不备份软件的缓存文件，通过测试发现钛备份还不会备份obb文件，还得需要手动备份一下，不过问题不大，毕竟用得到obb的还是少数软件，在专业版中可以很方便的使用一键备份和还原所有，计划备份，支持各种国外云备份以及加密也是不错的，可以说是瑕不掩瑜了。</p><p><code>Swift Backup</code>这个备份软件也很不错，支持Pro版计划备份，一键备份和还原，最重要的是支持obb·短信·通话·联系人备份！！，虽然仅支持Google Drive云备份，界面现代，一年订阅Pro1.99刀，5.99刀买断，还是很划算的。</p><p>备份文件分析的话，软件数据备份后，会有一个<code>.app</code>结尾的文件，后缀改成apk就是安装包，以<code>.dat</code>结尾的改成zip，里面压缩的就是上文提及到的各种软件数据文件夹(/data/下的)，以<code>.extdat</code>结尾的压缩的是<code>/storage/emulated/0/Android/data/</code>下的，以<code>.exp</code>结尾的是obb文件，只是改了个名字，大小没变。</p><p>另外还会生成一个<code>.xml</code>的文件，内容经过一些处理，不出意料和钛备份中的.<code>properties</code>文件作用差不多，如果我们在设置中设置了备份加密的话，密匙可能就是存在这个文件中。</p><p>至于备份通讯录和短信之类的文件涉及到数据库之类的，技术受限这里就不做分析了，感兴趣的可以尝试下。</p><p>备份工作做好就可以强刷固件了(Sony)，一般手机都是Recovery下卡刷ROM包的，具体流程Google一下各自手机型号刷机教程即可。</p><h2 id="管理优化"><a href="#管理优化" class="headerlink" title="管理优化"></a>管理优化</h2><p>由于Android的开放，给了一些软件滥用权限可乘之机，为了保护个人隐私和手机的流畅，必须采取一些措施对付了。</p><h3 id="管理工具软件"><a href="#管理工具软件" class="headerlink" title="管理工具软件"></a>管理工具软件</h3><p>建议先下一个类似于<code>Appops</code>的权限管理软件以及<code>黑阀</code>管理后台再安装各类软件，安装一个管理一个 如果你的手机能刷Xposed框架的话(推荐刷Magisk中的Systemless的Xposed)，有很多模块都很好用，由于我手机用的官方固件没法刷进Xposed…所以这里就只写点各类软件推荐。</p><ul><li>  Appops 管理软件的各种权限，可对付那种不给权限就不让用的流氓，但支付宝的SD卡读取权限压不住，仍可以读取，目前无解，大部分软件还是很管用的</li><li>  Brevent(黑阀) 管理软件后台的软件，很管用就是了</li><li>  SD Maid &amp; Dir 都是清理软件的，前者的话个人还用它来卸载和管理自启权限，后者的对国内流氓文件很棒</li><li>  Airfrozen(空调狗) 冻结流氓和不常用软件的，这类软件很多，只是我一直都是用的这个就是了 Play上都可以下到，管理软件就差不多这些了</li></ul><h3 id="使用IFW管理缓存活动唤醒"><a href="#使用IFW管理缓存活动唤醒" class="headerlink" title="使用IFW管理缓存活动唤醒"></a>使用IFW管理缓存活动唤醒</h3><p>除开以上提到的工具，还值得一提的是是IFW(<code>Intent Firewall</code>)这个玩意。</p><p>这是一个起到过滤到Intent的东西，在Android中软件都是使用Intent这个玩意启动新活动、新服务等，我们可以使用这个来阻止一些并不需要的东西开启。</p><p>系统是读取<code>/data/system/ifw/</code>下的xml来过滤掉Intent(允许多个文件，可叠加)，我们可以自己编写xml进行过滤，具体怎么写，可以参考<a href="https://selinuxproject.org/page/NB_SEforAndroid_2#ifw.xml">这里</a>，也直接使用已经写好的xml文件<a href="https://github.com/apkjam/IFW">Github</a> ，复制到<code>/data/system/ifw/</code>下，xml改成644权限，无需重启即刻生效。</p><p>有些流氓会检查自己申请的服务有没有正常开启，如果没有就会一直发送请求，反而会导致系统资源的消耗和设备耗电量的增加，仁者见仁吧，至少微信等软件后台缓存低了不少。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结?!"></a>总结?!</h2><p>现在手机性能普遍过剩，在我看来运用以上的方法管理好已经够用，最重要的还是保持良好的使用习惯，定时清理下垃圾，远离国内几大流氓厂，能用浏览器快捷解决的绝不下个软件，即使要下也去Play上下 愿国内安卓生态环境早日转好，虽然不抱什么希望就是了。</p>]]></content>
    
    
    <summary type="html">分析备份原理，推荐管理软件，并使用IFW管理缓存活动唤醒。</summary>
    
    
    
    <category term="大杂烩" scheme="https://blog.yuk7.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="Android" scheme="https://blog.yuk7.com/tags/Android/"/>
    
    <category term="备份" scheme="https://blog.yuk7.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
